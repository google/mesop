I will teach you how to use a Python UI framework called Mesop:

<page url='https://google.github.io/mesop/guides/state_management/'>
# State Management

State management is a critical element of building interactive apps because it allows you store information about what the user did in a structured way.

## Basic usage

You can register a class using the class decorator `me.stateclass` which is like a dataclass with special powers:

```python
@me.stateclass
class State:
  val: str
```

You can get an instance of the state class inside any of your Mesop component functions by using `me.state`:

```py
@me.page()
def page():
    state = me.state(State)
    me.text(state.val)
```

## Use immutable default values

Similar to [regular dataclasses which disallow mutable default values](https://docs.python.org/3/library/dataclasses.html#mutable-default-values), you need to avoid mutable default values such as list and dict for state classes. Using mutable default values can result in leaking state across sessions which can be a serious privacy issue.

You **MUST** use immutable default values _or_ use dataclasses `field` initializer _or_ not set a default value.

???+ success "Good: immutable default value"
      Setting a default value to an immutable type like str is OK.

      ```py
      @me.stateclass
      class State:
        a: str = "abc"
      ```

???+ failure "Bad: mutable default value"

    The following will raise an exception because dataclasses prevents you from using mutable collection types like `list` as the default value because this is a common footgun.

    ```py
    @me.stateclass
    class State:
      a: list[str] = ["abc"]
    ```

    If you set a default value to an instance of a custom type, an exception will not be raised, but you will be dangerously sharing the same mutable instance across sessions which could cause a serious privacy issue.

    ```py
    @me.stateclass
    class State:
      a: MutableClass = MutableClass()
    ```

???+ success "Good: default factory"

    If you want to set a field to a mutable default value, use default_factory in the `field`  function from the dataclasses module to create a new instance of the mutable default value for each instance of the state class.

    ```py
    from dataclasses import field

    @me.stateclass
    class State:
      a: list[str] = field(default_factory=lambda: ["abc"])
    ```

???+ success "Good: no default value"

    If you want a default of an empty list, you can just not define a default value and Mesop will automatically define an empty list default value.

    For example, if you write the following:

    ```py
    @me.stateclass
    class State:
      a: list[str]
    ```

    It's the equivalent of:

    ```py
    @me.stateclass
    class State:
      a: list[str] = field(default_factory=list)
    ```

## How State Works

`me.stateclass` is a class decorator which tells Mesop that this class can be retrieved using the `me.state` method, which will return the state instance for the current user session.

> If you are familiar with the dependency injection pattern, Mesop's stateclass and state API is essentially a minimalist dependency injection system which scopes the state object to the lifetime of a user session.

Under the hood, Mesop is sending the state back and forth between the server and browser client so everything in a state class must be serializable.

## Multiple state classes

You can use multiple classes to store state for the current user session.

Using different state classes for different pages or components can help make your app easier to maintain and more modular.

```py
@me.stateclass
class PageAState:
    ...

@me.stateclass
class PageBState:
    ...

@me.page(path="/a")
def page_a():
    state = me.state(PageAState)
    ...

@me.page(path="/b")
def page_b():
    state = me.state(PageBState)
    ...
```

Under the hood, Mesop is managing state classes based on the identity (e.g. module name and class name) of the state class, which means that you could have two state classes named "State", but if they are in different modules, then they will be treated as separate state, which is what you would expect.

## Nested State

You can also have classes inside of a state class as long as everything is serializable:

```python
class NestedState:
  val: str

@me.stateclass
class State:
  nested: NestedState

def app():
  state = me.state(State)
```

> Note: you only need to decorate the top-level state class with `@me.stateclass`. All the nested state classes will automatically be wrapped.

### Nested State and dataclass

Sometimes, you may want to explicitly decorate the nested state class with `dataclass` because in the previous example, you couldn't directly instantiate `NestedState`.

If you wanted to use NestedState as a general dataclass, you can do the following:

```python
@dataclass
class NestedState:
  val: str = ""

@me.stateclass
class State:
  nested: NestedState

def app():
  state = me.state(State)
```

> Reminder: because dataclasses do not have default values, you will need to explicitly set default values, otherwise Mesop will not be able to instantiate an empty version of the class.

Now, if you have an event handler function, you can do the following:

```py
def on_click(e):
    response = call_api()
    state = me.state(State)
    state.nested = NestedState(val=response.text)
```

If you didn't explicitly annotate NestedState as a dataclass, then you would get an error instantiating NestedState because there's no initializer defined.

## Tips

### State performance issues

Because the state class is serialized and sent back and forth between the client and server, you should try to keep the state class reasonably sized. For example, if you store a very large string (e.g. base64-encoded image) in state, then it will degrade performance of your Mesop app. Instead, you should try to store large data outside of the state class (e.g. in-memory, filesystem, database, external service) and retrieve the data as needed for rendering.

#### Storing state in memory

Mesop has a feature that allows you to store state in memory rather than passing the
full state on every request. This may help improve performance when dealing with large
state objects. The caveat is that storing state in memory contains its own set of
problems that you must carefully consider. See the [config section](../api/config.md#mesop_state_session_backend)
for details on how to use this feature.
</page>

<page url='https://google.github.io/mesop/guides/interactivity/'>
# Interactivity

This guide continues from the Counter app example in [Core Concepts](../getting_started/core_concepts.md#counter-app) and explains advanced interactivity patterns for dealing with common use cases such as calling a slow blocking API call or a streaming API call.

## Intermediate loading state

If you are calling a slow blocking API (e.g. several seconds) to provide a better user experience, you may want to introduce a custom loading indicator for a specific event.

> Note: Mesop has a built-in loading indicator at the top of the page for all events.

```python
--8<-- "mesop/examples/docs/loading.py"
```

In this example, our event handler is a Python generator function. Each `yield` statement yields control back to the Mesop framework and executes a render loop which results in a UI update.

Before the first yield statement, we set `is_loading` to True on state so we can show a spinner while the user is waiting for the slow API call to complete.

Before the second (and final) yield statement, we set `is_loading` to False, so we can hide the spinner and then we add the result of the API call to state so we can display that to the user.

> Tip: you must have a yield statement as the last line of a generator event handler function. Otherwise, any code after the final yield will not be executed.

## Streaming

This example builds off the previous Loading example and makes our event handler a generator function so we can incrementally update the UI.

```python
--8<-- "mesop/examples/docs/streaming.py"
```

## Troubleshooting

### User input race condition

If you notice a race condition with user input (e.g. [input](../components/input.md) or [textarea](../components/textarea.md)) where sometimes the last few characters typed by the user is lost, you are probably unnecessarily setting the value of the component.

See the following example using this **anti-pattern** :warning::

```py title="Bad example"
@me.stateclass
class State:
  input_value: str

def app():
  state = me.state(State)
  me.input(value=state.input_value, on_input=on_input)

def on_input(event: me.InputEvent):
  state = me.state(State)
  state.input_value = event.value
```

The problem is that the input value now has a race condition because it's being set by two sources:

1. The server is setting the input value based on state.
2. The client is setting the input value based on what the user is typing.

The way to fix this is by *not* setting the input value from the server.

The above example **corrected** would look like this :white_check_mark::

```py title="Good example" hl_lines="7"
@me.stateclass
class State:
  input_value: str

def app():
  state = me.state(State)
  me.input(on_input=on_input)

def on_input(event: me.InputEvent):
  state = me.state(State)
  state.input_value = event.value
```

### Avoid using closure variables in event handler

One subtle mistake when building a reusable component is to have the event handler use a closure variable like the following example:

```py title="Bad example of using closure variable"
@me.component
def link_component(url: str):
   def on_click(event: me.ClickEvent):
     me.navigate(url)
  return me.button(url, on_click=on_click)

def app():
    link_component("/1")
    link_component("/2")
```

The problem with this above example is that Mesop only stores the last event handler. This means that both instances of the link_component will refer to the last `on_click` instance which references the same `url` closure variable set to `"/2"`. This almost always produces the wrong behavior.

Instead, you will want to use the pattern of relying on the key in the event handler as demonstrated in the following example:

```py title="Good example of using key"
@me.component
def link_component(url: str):
   def on_click(event: me.ClickEvent):
     me.navigate(event.key)
  return me.button(url, key=url, on_click=on_click)
```

For more info on using component keys, please refer to the [Component Key docs](../components/index.md#component-key).
</page>

<page url='https://google.github.io/mesop/guides/theming/'>
# Theming

Mesop has early-stage support for theming so you can support light theme and dark theme in a Mesop application.

## Example

For an actual example of using Mesop's theming API to support light theme and dark theme, we will look at the labs [chat component](../components/chat.md) which itself is written all in Python built on top of lower-level Mesop components.

### Theme toggle button

Inside the chat component, we've defined an icon button to toggle the theme so users can switch between light and dark theme:

```py
def toggle_theme(e: me.ClickEvent):
    if me.theme_brightness() == "light":
      me.set_theme_mode("dark")
    else:
      me.set_theme_mode("light")

with me.content_button(
    type="icon",
    style=me.Style(position="absolute", right=0),
    on_click=toggle_theme,
):
    me.icon("light_mode" if me.theme_brightness() == "dark" else "dark_mode")
```

### Using theme colors

You could define custom style logic to explicitly set the color based on the theme:

```py
def container():
  me.box(
    style=me.Style(
      background="white" if me.theme_brightness() == "light" else "black"
    )
  )
```

But this would be pretty tedious, so you can use theme variables like this:


```py
def container():
  me.box(style=me.Style(background=me.theme_var("background")))
```

This will use the appropriate background color for light theme and dark theme.

### Default theme mode

Finally, we want to use the default theme mode to "system" which means we will use the user's preferences for whether they want dark theme or light theme. For many users, their operating systems will automatically switch to dark theme during night time.

> Note: Mesop currently defaults to light theme mode but will eventually default to system theme mode in the future.

On our demo page with the chat component, we have a page [on_load](../api/page.md#on_load) event handler defined like this:

```py
def on_load(e: me.LoadEvent):
  me.set_theme_mode("system")
```

## API

::: mesop.features.theme.set_theme_mode
::: mesop.features.theme.theme_brightness
::: mesop.features.theme.theme_var
::: mesop.features.theme.ThemeVar
</page>

<page url='https://google.github.io/mesop/guides/multi_pages/'>
# Multi-Pages

You can define multi-page Mesop applications by using the page feature you learned from [Core Concepts](../getting_started/core_concepts.md).

## Multi-page setup

```python
import mesop as me

@me.page(path="/1")
def page1():
    me.text("page 1")

@me.page(path="/2")
def page2():
    me.text("page 2")
```

Learn more about page configuration in the [page API doc](../api/page.md).

## Navigation

If you have multiple pages, you will typically want to navigate from one page to another when the user clicks a button. You can use `me.navigate("/to/path")` to navigate to another page.

**Example:**

```python
--8<-- "mesop/examples/docs/multi_page_nav.py"
```

> Note: you can re-use state across pages. See how the above example uses the `State#count` value across pages.
</page>

<page url='https://google.github.io/mesop/api/viewport_size/'>
# Viewport size

## Overview
The viewport size API allows you to access the current viewport size. This can be useful for creating responsive and adaptive designs that are suitable for the user's screen size.

## Examples

### Responsive Design

Responsive design is having a single fluid layout that adapts to all screen sizes.

You can use the viewport size to dynamically set the property of a style. This can be useful if you want to fit two boxes in a row for larger screens (e.g. desktop) and a single box for smaller screens (e.g. mobile) as shown in the example below:

```py
import mesop as me

@me.page()
def page():
    if me.viewport_size().width > 640:
        width = me.viewport_size().width / 2
    else:
        width = me.viewport_size().width
    for i in range(8):
      me.box(style=me.Style(width=width))
```

> Tip: Responsive design tends to take less work and is usually a good starting point.

### Adaptive Design

Adaptive design is having multiple fixed layouts for specific device categories at specific breakpoints, typically viewport width.

For example, oftentimes you will hide the nav component on a mobile device and instead show a hamburger menu, while for a larger device you will always show the nav component on the left side.

```py
import mesop as me

@me.page()
def page():
    if me.viewport_size().width > 480:
        nav_component()
        body()
    else:
        body(show_menu_button=True)
```

> Tip: Adaptive design tends to take more work and is best for optimizing complex mobile and desktop experiences.

## API

::: mesop.features.viewport_size.viewport_size

::: mesop.features.viewport_size.Size
</page>


<page url='https://google.github.io/mesop/api/page/'>
# Page API

## Overview

Pages allow you to build multi-page applications by decorating Python functions with `me.page`. To learn more, read the see [multi-pages guide](../guides/multi_pages.md).

## Examples

### Simple, 1-page setup

To create a simple Mesop app, you can use `me.page()` like this:

```python
import mesop as me

@me.page()
def foo():
    me.text("bar")
```

> NOTE: If you do not provide a `path` argument, then it defaults to the root path `"/"`.

### Explicit 1-page setup

This is the same as the above example which explicitly sets the route to `"/"`.

```python
import mesop as me

@me.page(path="/")
def foo():
    me.text("bar")
```

## API

::: mesop.features.page.page
::: mesop.security.security_policy.SecurityPolicy
::: mesop.events.events.LoadEvent

## `on_load`

You may want to do some sort of data-processing when a page is first loaded in a session.

### Simple handler

An `on_load` handler is similar to a regular event handler where you can mutate state.

```python
--8<-- "mesop/examples/docs/on_load.py"
```

### Generator handler

The `on_load` handler can also be a generator function. This is useful if you need to call a slow or streaming API and want to return intermediate results before all the data has been received.

```python
--8<-- "mesop/examples/docs/on_load_generator.py"
```
</page>

<page url='https://google.github.io/mesop/api/commands/navigate/'>
# Navigate

To navigate to another page, you can use `me.navigate`. This is particularly useful for navigating across a [multi-page](../../guides/multi_pages.md) app.

## Example

```python
--8<-- "mesop/examples/navigate.py"
```

## API

::: mesop.commands.navigate.navigate
</page>

<page url='https://google.github.io/mesop/api/commands/scroll_into_view/'>
# Scroll into view

If you want to scroll a component into the viewport, you can use `me.scroll_into_view` which scrolls the component with the specified key into the viewport.

## Example

```python
--8<-- "mesop/examples/scroll_into_view.py"
```

## API

::: mesop.commands.scroll_into_view.scroll_into_view
</page>

<page url='https://google.github.io/mesop/getting_started/core_concepts/'>
This doc will explain the core concepts of building a Mesop app.

## Hello World app

Let's start by creating a simple Hello World app in Mesop:

```python
--8<-- "mesop/examples/docs/hello_world.py"
```

This simple example demonstrates a few things:

- Every Mesop app starts with `import mesop as me`. This is the only recommended way to import mesop, otherwise your app may break in the future because you may be relying on internal implementation details.
- `@me.page` is a function decorator which makes a function a _root component_ for a particular path. If you omit the `path` parameter, this is the equivalent of `@me.page(path="/")`.
- `app` is a Python function that we will call a __component__ because it's creating Mesop components in the body.

## Components

Components are the building blocks of a Mesop application. A Mesop application is essentially a tree of components.

Let's explain the different kinds of components in Mesop:

- Mesop comes built-in with __native__ components. These are components implemented using Angular/Javascript. Many of these components wrap [Angular Material components](https://material.angular.io/components/).
- You can also create your own components which are called __user-defined__ components. These are essentially Python functions like `app` in the previous example.

## Counter app

Let's build a more complex app to demonstrate Mesop's interactivity features.

```python
--8<-- "mesop/examples/docs/counter.py"
```

This app allows the user to click on a button and increment a counter, which is shown to the user as "Clicks: #".

Let's walk through this step-by-step.

### State

The `State` class represents the application state for a particular browser session. This means every user session has its own instance of `State`.

`@me.stateclass` is a class decorator which is similar to Python's [dataclass](https://docs.python.org/3/library/dataclasses.html) but also sets default values based on type hints and allows Mesop to inject the class as shown next.

> Note: Everything in a state class must be serializable because it's sent between the server and browser.

### Event handler

The `button_click` function is an event handler. An event handler has a single parameter, `event`, which can contain a value (this will be shown in the next example). An event handler is responsible for updating state based on the incoming event.

`me.state(State)` retrieves the instance of the state class for the current session.

### Component

Like the previous example, `main` is a Mesop component function which is decorated with `page` to mark it as a root component for a path.

Similar to the event handler, we can retrieve the state in a component function by calling `me.state(State)`.

> Note: it's _not_ safe to mutate state inside a component function. All mutations must be done in an event handler.

Rendering dynamic values in Mesop is simple because you can use standard Python string interpolation use f-strings:

```python
me.text(f"Clicks: {state.clicks}")
```

The button component demonstrates connecting an event handler to a component. Whenever a click event is triggered by the component, the registered event handler function is called:

```python
me.button("Increment", on_click=button_click)
```

In summary, you've learned how to define a state class, an event handler and wire them together using interactive components.

## What's next

At this point, you've learned all the basics of building a Mesop app. For a step-by-step guide for building a real-world Mesop application, check out the DuoChat Codelab:

<a href="../../codelab" class="next-step">
    DuoChat Codelab
</a>
</page>

These are all the components and their APIs:

<page url=''>
from typing import Callable

import mesop as me


@me.stateclass
class State:
  input: str
  output: str
  textarea_key: int


def text_to_image(
  transform: Callable[[str], str],
  *,
  title: str | None = None,
):
  """Creates a simple UI which takes in a text input and returns an image output.

  This function creates event handlers for text input and output operations
  using the provided function `transform` to process the input and generate the image
  output.

  Args:
    transform: Function that takes in a string input and returns a URL to an image or a base64 encoded image.
    title: Headline text to display at the top of the UI.
  """

  def on_input(e: me.InputEvent):
    state = me.state(State)
    state.input = e.value

  def on_click_generate(e: me.ClickEvent):
    state = me.state(State)
    state.output = transform(state.input)

  def on_click_clear(e: me.ClickEvent):
    state = me.state(State)
    state.input = ""
    state.output = ""
    state.textarea_key += 1

  with me.box(
    style=me.Style(
      background="#f0f4f8",
      height="100%",
    )
  ):
    with me.box(
      style=me.Style(
        background="#f0f4f8",
        padding=me.Padding(top=24, left=24, right=24, bottom=24),
        display="flex",
        flex_direction="column",
      )
    ):
      if title:
        me.text(title, type="headline-5")
      with me.box(
        style=me.Style(
          margin=me.Margin(left="auto", right="auto"),
          width="min(1024px, 100%)",
          gap="24px",
          flex_grow=1,
          display="flex",
          flex_wrap="wrap",
        )
      ):
        box_style = me.Style(
          flex_basis="max(480px, calc(50% - 48px))",
          background="#fff",
          border_radius=12,
          box_shadow=(
            "0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"
          ),
          padding=me.Padding(top=16, left=16, right=16, bottom=16),
          display="flex",
          flex_direction="column",
        )

        with me.box(style=box_style):
          me.text("Input", style=me.Style(font_weight=500))
          me.box(style=me.Style(height=16))
          me.textarea(
            key=str(me.state(State).textarea_key),
            on_input=on_input,
            rows=5,
            autosize=True,
            max_rows=15,
            style=me.Style(width="100%"),
          )
          me.box(style=me.Style(height=12))
          with me.box(
            style=me.Style(display="flex", justify_content="space-between")
          ):
            me.button(
              "Clear",
              color="primary",
              type="stroked",
              on_click=on_click_clear,
            )
            me.button(
              "Generate",
              color="primary",
              type="flat",
              on_click=on_click_generate,
            )
        with me.box(style=box_style):
          me.text("Output", style=me.Style(font_weight=500))
          if me.state(State).output:
            with me.box(
              style=me.Style(
                display="grid",
                justify_content="center",
                justify_items="center",
              )
            ):
              me.image(
                src=me.state(State).output,
                style=me.Style(width="100%", margin=me.Margin(top=10)),
              )
</page>


<page url=''>
import types
from typing import Callable, Generator, Literal, cast

import mesop as me


@me.stateclass
class State:
  input: str
  output: str
  textarea_key: int


def text_io(
  transform: Callable[[str], Generator[str, None, None] | str],
  *,
  title: str | None = None,
  transform_mode: Literal["append", "replace"] = "replace",
):
  """Deprecated: Use `text_to_text` instead which provides the same functionality
  with better default settings.

  This function creates event handlers for text input and output operations
  using the provided transform function to process the input and generate the output.

  Args:
    transform: Function that takes in a string input and either returns or yields a string output.
    title: Headline text to display at the top of the UI
    transform_mode: Specifies how the output should be updated when yielding an output using a generator.
                  - "append": Concatenates each new piece of text to the existing output.
                  - "replace": Replaces the existing output with each new piece of text.
  """
  print(
    "\033[93m[warning]\033[0m text_io is deprecated, use text_to_text instead"
  )
  text_to_text(transform=transform, title=title, transform_mode=transform_mode)


def text_to_text(
  transform: Callable[[str], Generator[str, None, None] | str],
  *,
  title: str | None = None,
  transform_mode: Literal["append", "replace"] = "append",
):
  """Creates a simple UI which takes in a text input and returns a text output.

  This function creates event handlers for text input and output operations
  using the provided transform function to process the input and generate the output.

  Args:
    transform: Function that takes in a string input and either returns or yields a string output.
    title: Headline text to display at the top of the UI
    transform_mode: Specifies how the output should be updated when yielding an output using a generator.
                  - "append": Concatenates each new piece of text to the existing output.
                  - "replace": Replaces the existing output with each new piece of text.
  """

  def on_input(e: me.InputEvent):
    state = me.state(State)
    state.input = e.value

  def on_click_generate(e: me.ClickEvent):
    state = me.state(State)
    output = transform(state.input)
    if isinstance(output, types.GeneratorType):
      for val in output:
        if transform_mode == "append":
          state.output += val
        elif transform_mode == "replace":
          state.output = val
        else:
          raise ValueError(f"Unsupported transform_mode: {transform_mode}")
        yield
    else:
      # `output` is a str, however type inference doesn't
      # work w/ generator's unusual ininstance check.
      state.output = cast(str, output)
      yield

  def on_click_clear(e: me.ClickEvent):
    state = me.state(State)
    state.input = ""
    state.textarea_key += 1

  with me.box(
    style=me.Style(
      background="#f0f4f8",
      height="100%",
    )
  ):
    with me.box(
      style=me.Style(
        background="#f0f4f8",
        padding=me.Padding(top=24, left=24, right=24, bottom=24),
        display="flex",
        flex_direction="column",
      )
    ):
      if title:
        me.text(title, type="headline-5")
      with me.box(
        style=me.Style(
          margin=me.Margin(left="auto", right="auto"),
          width="min(1024px, 100%)",
          gap="24px",
          flex_grow=1,
          display="flex",
          flex_wrap="wrap",
        )
      ):
        box_style = me.Style(
          flex_basis="max(480px, calc(50% - 48px))",
          background="#fff",
          border_radius=12,
          box_shadow="0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f",
          padding=me.Padding(top=16, left=16, right=16, bottom=16),
          display="flex",
          flex_direction="column",
        )
        with me.box(style=box_style):
          me.text("Input", style=me.Style(font_weight=500))
          me.box(style=me.Style(height=16))
          me.textarea(
            key=str(me.state(State).textarea_key),
            on_input=on_input,
            rows=5,
            autosize=True,
            max_rows=15,
            style=me.Style(width="100%"),
          )
          me.box(style=me.Style(height=12))
          with me.box(
            style=me.Style(display="flex", justify_content="space-between")
          ):
            me.button(
              "Clear", color="primary", type="stroked", on_click=on_click_clear
            )
            me.button(
              "Generate",
              color="primary",
              type="flat",
              on_click=on_click_generate,
            )
        with me.box(style=box_style):
          me.text("Output", style=me.Style(font_weight=500))
          me.markdown(me.state(State).output)
</page>

<page url=''>
import time
from dataclasses import dataclass
from typing import Callable, Generator, Literal

import mesop as me

Role = Literal["user", "assistant"]

_ROLE_USER = "user"
_ROLE_ASSISTANT = "assistant"

_BOT_USER_DEFAULT = "mesop-bot"

_COLOR_BACKGROUND = me.theme_var("background")
_COLOR_CHAT_BUBBLE_YOU = me.theme_var("surface-container-low")
_COLOR_CHAT_BUBBLE_BOT = me.theme_var("secondary-container")

_DEFAULT_PADDING = me.Padding.all(20)
_DEFAULT_BORDER_SIDE = me.BorderSide(
  width="1px", style="solid", color=me.theme_var("secondary-fixed")
)

_LABEL_BUTTON = "send"
_LABEL_BUTTON_IN_PROGRESS = "pending"
_LABEL_INPUT = "Enter your prompt"

_STYLE_APP_CONTAINER = me.Style(
  background=_COLOR_BACKGROUND,
  display="grid",
  height="100vh",
  grid_template_columns="repeat(1, 1fr)",
)
_STYLE_TITLE = me.Style(padding=me.Padding(left=10))
_STYLE_CHAT_BOX = me.Style(
  height="100%",
  overflow_y="scroll",
  padding=_DEFAULT_PADDING,
  margin=me.Margin(bottom=20),
  border_radius="10px",
  border=me.Border(
    left=_DEFAULT_BORDER_SIDE,
    right=_DEFAULT_BORDER_SIDE,
    top=_DEFAULT_BORDER_SIDE,
    bottom=_DEFAULT_BORDER_SIDE,
  ),
)
_STYLE_CHAT_INPUT = me.Style(width="100%")
_STYLE_CHAT_INPUT_BOX = me.Style(
  padding=me.Padding(top=30), display="flex", flex_direction="row"
)
_STYLE_CHAT_BUTTON = me.Style(margin=me.Margin(top=8, left=8))
_STYLE_CHAT_BUBBLE_NAME = me.Style(
  font_weight="bold",
  font_size="13px",
  padding=me.Padding(left=15, right=15, bottom=5),
)
_STYLE_CHAT_BUBBLE_PLAINTEXT = me.Style(margin=me.Margin.symmetric(vertical=15))


def _make_style_chat_ui_container(has_title: bool) -> me.Style:
  """Generates styles for chat UI container depending on if there is a title or not.

  Args:
    has_title: Whether the Chat UI is display a title or not.
  """
  return me.Style(
    display="grid",
    grid_template_columns="repeat(1, 1fr)",
    grid_template_rows="1fr 14fr 1fr" if has_title else "5fr 1fr",
    margin=me.Margin.symmetric(vertical=0, horizontal="auto"),
    width="min(1024px, 100%)",
    height="100vh",
    background=_COLOR_BACKGROUND,
    box_shadow=(
      "0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"
    ),
    padding=me.Padding(top=20, left=20, right=20),
  )


def _make_style_chat_bubble_wrapper(role: Role) -> me.Style:
  """Generates styles for chat bubble position.

  Args:
    role: Chat bubble alignment depends on the role
  """
  align_items = "end" if role == _ROLE_USER else "start"
  return me.Style(
    display="flex",
    flex_direction="column",
    align_items=align_items,
  )


def _make_chat_bubble_style(role: Role) -> me.Style:
  """Generates styles for chat bubble.

  Args:
    role: Chat bubble background color depends on the role
  """
  background = (
    _COLOR_CHAT_BUBBLE_YOU if role == _ROLE_USER else _COLOR_CHAT_BUBBLE_BOT
  )
  return me.Style(
    width="80%",
    font_size="16px",
    line_height="1.5",
    background=background,
    border_radius="15px",
    padding=me.Padding(right=15, left=15, bottom=3),
    margin=me.Margin(bottom=10),
    border=me.Border(
      left=_DEFAULT_BORDER_SIDE,
      right=_DEFAULT_BORDER_SIDE,
      top=_DEFAULT_BORDER_SIDE,
      bottom=_DEFAULT_BORDER_SIDE,
    ),
  )


@dataclass(kw_only=True)
class ChatMessage:
  """Chat message metadata."""

  role: Role = "user"
  content: str = ""


@me.stateclass
class State:
  input: str
  output: list[ChatMessage]
  in_progress: bool = False


def on_blur(e: me.InputBlurEvent):
  state = me.state(State)
  state.input = e.value


def chat(
  transform: Callable[
    [str, list[ChatMessage]], Generator[str, None, None] | str
  ],
  *,
  title: str | None = None,
  bot_user: str = _BOT_USER_DEFAULT,
):
  """Creates a simple chat UI which takes in a prompt and chat history and returns a
  response to the prompt.

  This function creates event handlers for text input and output operations
  using the provided function `transform` to process the input and generate the output.

  Args:
    transform: Function that takes in a prompt and chat history and returns a response to the prompt.
    title: Headline text to display at the top of the UI.
    bot_user: Name of your bot / assistant.
  """
  state = me.state(State)

  def on_click_submit(e: me.ClickEvent):
    yield from submit()

  def on_input_enter(e: me.InputEnterEvent):
    state = me.state(State)
    state.input = e.value
    yield from submit()

  def submit():
    state = me.state(State)
    if state.in_progress or not state.input:
      return
    input = state.input
    state.input = ""
    yield

    output = state.output
    if output is None:
      output = []
    output.append(ChatMessage(role=_ROLE_USER, content=input))
    state.in_progress = True
    yield

    me.scroll_into_view(key="scroll-to")
    time.sleep(0.15)
    yield

    start_time = time.time()
    output_message = transform(input, state.output)
    assistant_message = ChatMessage(role=_ROLE_ASSISTANT)
    output.append(assistant_message)
    state.output = output

    for content in output_message:
      assistant_message.content += content
      # TODO: 0.25 is an abitrary choice. In the future, consider making this adjustable.
      if (time.time() - start_time) >= 0.25:
        start_time = time.time()
        yield
    state.in_progress = False
    yield

  def toggle_theme(e: me.ClickEvent):
    if me.theme_brightness() == "light":
      me.set_theme_mode("dark")
    else:
      me.set_theme_mode("light")

  with me.box(style=_STYLE_APP_CONTAINER):
    with me.content_button(
      type="icon",
      style=me.Style(position="absolute", right=4, top=8),
      on_click=toggle_theme,
    ):
      me.icon("light_mode" if me.theme_brightness() == "dark" else "dark_mode")
    with me.box(style=_make_style_chat_ui_container(bool(title))):
      if title:
        me.text(title, type="headline-5", style=_STYLE_TITLE)
      with me.box(style=_STYLE_CHAT_BOX):
        for msg in state.output:
          with me.box(style=_make_style_chat_bubble_wrapper(msg.role)):
            if msg.role == _ROLE_ASSISTANT:
              me.text(bot_user, style=_STYLE_CHAT_BUBBLE_NAME)
            with me.box(style=_make_chat_bubble_style(msg.role)):
              if msg.role == _ROLE_USER:
                me.text(msg.content, style=_STYLE_CHAT_BUBBLE_PLAINTEXT)
              else:
                me.markdown(msg.content)

        if state.in_progress:
          with me.box(key="scroll-to", style=me.Style(height=300)):
            pass

      with me.box(style=_STYLE_CHAT_INPUT_BOX):
        with me.box(style=me.Style(flex_grow=1)):
          me.input(
            label=_LABEL_INPUT,
            # Workaround: update key to clear input.
            key=f"{len(state.output)}",
            on_blur=on_blur,
            on_enter=on_input_enter,
            style=_STYLE_CHAT_INPUT,
          )
        with me.content_button(
          color="primary",
          type="flat",
          disabled=state.in_progress,
          on_click=on_click_submit,
          style=_STYLE_CHAT_BUTTON,
        ):
          me.icon(
            _LABEL_BUTTON_IN_PROGRESS if state.in_progress else _LABEL_BUTTON
          )
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Literal, Sequence

import mesop.components.uploader.uploader_pb2 as uploader_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.components.uploader.uploaded_file import UploadedFile
from mesop.events import MesopEvent
from mesop.exceptions import MesopDeveloperException


@dataclass(kw_only=True)
class UploadEvent(MesopEvent):
  """Event for file uploads.

  Attributes:
      file: Uploaded file.
  """

  file: UploadedFile


@register_native_component
def uploader(
  *,
  label: str,
  accepted_file_types: Sequence[str] | None = None,
  key: str | None = None,
  on_upload: Callable[[UploadEvent], Any] | None = None,
  type: Literal["raised", "flat", "stroked"] | None = None,
  color: Literal["primary", "accent", "warn"] | None = None,
  disable_ripple: bool = False,
  disabled: bool = False,
  style: Style | None = None,
):
  """
  This function creates an uploader.

  Args:
      label: Upload button label.
      accepted_file_types: List of accepted file types. See the [accept parameter](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept).
      key: The component [key](../components/index.md#component-key).
      on_upload: File upload event handler.
      type: Type of button style to use
      color: Theme color palette of the button
      disable_ripple: Whether the ripple effect is disabled or not.
      disabled: Whether the button is disabled.
      style: Style for the component.
  """
  insert_component(
    key=key,
    type_name="uploader",
    proto=uploader_pb.UploaderType(
      label=label,
      accepted_file_type=accepted_file_types or [],
      on_upload_event_handler_id=register_event_handler(
        on_upload, event=UploadEvent
      )
      if on_upload
      else "",
      type_index=_get_type_index(type),
      type=type,
      color=color,
      disable_ripple=disable_ripple,
      disabled=disabled,
    ),
    style=style,
  )


def _get_type_index(
  type: Literal["raised", "flat", "stroked"] | None,
) -> int:
  if type is None:
    return 0
  if type == "raised":
    return 1
  if type == "flat":
    return 2
  if type == "stroked":
    return 3
  raise Exception("Unexpected type: " + type)
</page>

<page url=''>
import io


# Store this class in a separate file so we can more easily reference
# in dataclass utils.
class UploadedFile(io.BytesIO):
  """Uploaded file contents and metadata."""

  def __init__(
    self,
    contents: bytes = b"",
    *,
    name: str = "",
    size: int = 0,
    mime_type: str = "",
  ):
    super().__init__(contents)
    self._name = name
    self._size = size
    self._mime_type = mime_type

  @property
  def name(self):
    return self._name

  @property
  def size(self):
    return self._size

  @property
  def mime_type(self):
    return self._mime_type

  def __eq__(self, other):
    if isinstance(other, UploadedFile):
      return (self.getvalue(), self.name, self.size, self.mime_type) == (
        other.getvalue(),
        other.name,
        other.size,
        other.mime_type,
      )
    return False
</page>

<page url=''>
from . import uploader_app as uploader_app
</page>

<page url=''>
import base64

import mesop as me


@me.stateclass
class State:
  file: me.UploadedFile


@me.page(path="/components/uploader/e2e/uploader_app")
def app():
  state = me.state(State)
  with me.box(style=me.Style(padding=me.Padding.all(15))):
    me.uploader(
      label="Upload Image",
      accepted_file_types=["image/jpeg", "image/png"],
      on_upload=handle_upload,
      type="flat",
      color="primary",
      style=me.Style(font_weight="bold"),
    )

    if state.file.size:
      with me.box(style=me.Style(margin=me.Margin.all(10))):
        me.text(f"File name: {state.file.name}")
        me.text(f"File size: {state.file.size}")
        me.text(f"File type: {state.file.mime_type}")

      with me.box(style=me.Style(margin=me.Margin.all(10))):
        me.image(src=_convert_contents_data_url(state.file))


def handle_upload(event: me.UploadEvent):
  state = me.state(State)
  state.file = event.file


def _convert_contents_data_url(file: me.UploadedFile) -> str:
  return (
    f"data:{file.mime_type};base64,{base64.b64encode(file.getvalue()).decode()}"
  )
</page>

<page url=''>
import mesop.components.video.video_pb2 as video_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def video(
  *,
  src: str,
  style: Style | None = None,
  key: str | None = None,
):
  """
  Creates a video.

  Args:
      src: URL of the video source
      style: The style to apply to the image, such as width and height.
  """
  insert_component(
    key=key,
    type_name="video",
    proto=video_pb.VideoType(
      src=src,
    ),
    style=style,
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/video/e2e/video_app")
def app():
  me.video(
    src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm",
    style=me.Style(height=300, width=300),
  )
</page>

<page url=''>
from . import video_app as video_app
</page>

<page url=''>
from typing import Literal

import mesop.components.tooltip.tooltip_pb2 as tooltip_pb
from mesop.component_helpers import (
  insert_composite_component,
  register_native_component,
)


@register_native_component
def tooltip(
  *,
  key: str | None = None,
  position: Literal[
    "left", "right", "above", "below", "before", "after"
  ] = "left",
  position_at_origin: bool = False,
  disabled: bool = False,
  show_delay_ms: int = 0,
  hide_delay_ms: int = 0,
  message: str = "",
):
  """Creates a Tooltip component.
  Tooltip is a composite component.

  Args:
    key: The component [key](../components/index.md#component-key).
    position: Allows the user to define the position of the tooltip relative to the parent element
    position_at_origin: Whether tooltip should be relative to the click or touch origin instead of outside the element bounding box.
    disabled: Disables the display of the tooltip.
    show_delay_ms: The default delay in ms before showing the tooltip after show is called
    hide_delay_ms: The default delay in ms before hiding the tooltip after hide is called
    message: The message to be displayed in the tooltip
  """
  return insert_composite_component(
    key=key,
    type_name="tooltip",
    proto=tooltip_pb.TooltipType(
      position=position,
      position_at_origin=position_at_origin,
      disabled=disabled,
      show_delay_ms=show_delay_ms,
      hide_delay_ms=hide_delay_ms,
      message=message,
    ),
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/tooltip/e2e/tooltip_app")
def app():
  with me.tooltip(message="Hello, world!"):
    me.text(text="sometext")
</page>

<page url=''>
from . import tooltip_app as tooltip_app
</page>

<page url=''>
import mesop.components.sidenav.sidenav_pb2 as sidenav_pb
from mesop.component_helpers import (
  Style,
  insert_composite_component,
  register_native_component,
)


@register_native_component
def sidenav(
  *,
  opened: bool = True,
  style: Style | None = None,
  key: str | None = None,
):
  """
  This function creates a sidenav.

  Args:
      opened: A flag to determine if the sidenav is open or closed. Defaults to True.
      style: An optional Style object to apply custom styles. Defaults to None.
      key: The component [key](../components/index.md#component-key).
  """
  return insert_composite_component(
    key=key,
    type_name="sidenav",
    style=style,
    proto=sidenav_pb.SidenavType(
      opened=opened,
    ),
  )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  sidenav_open: bool


def on_click(e: me.ClickEvent):
  s = me.state(State)
  s.sidenav_open = not s.sidenav_open


SIDENAV_WIDTH = 200


@me.page(path="/components/sidenav/e2e/sidenav_app")
def app():
  state = me.state(State)
  with me.sidenav(
    opened=state.sidenav_open, style=me.Style(width=SIDENAV_WIDTH)
  ):
    me.text("Inside sidenav")

  with me.box(
    style=me.Style(
      margin=me.Margin(left=SIDENAV_WIDTH if state.sidenav_open else 0),
    ),
  ):
    with me.content_button(on_click=on_click):
      me.icon("menu")
    me.markdown("Main content")
</page>

<page url=''>
from typing import Literal

import mesop.components.progress_spinner.progress_spinner_pb2 as progress_spinner_pb
from mesop.component_helpers import (
  insert_component,
  register_native_component,
)


@register_native_component
def progress_spinner(
  *,
  key: str | None = None,
  color: Literal["primary", "accent", "warn"] | None = None,
  diameter: float = 48,
  stroke_width: float = 4,
):
  """Creates a Progress spinner component.

  Args:
    key: The component [key](../components/index.md#component-key).
    color: Theme palette color of the progress spinner.
    diameter: The diameter of the progress spinner (will set width and height of svg).
    stroke_width: Stroke width of the progress spinner.
  """
  insert_component(
    key=key,
    type_name="progress_spinner",
    proto=progress_spinner_pb.ProgressSpinnerType(
      color=color,
      diameter=diameter,
      stroke_width=stroke_width,
    ),
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/progress_spinner/e2e/progress_spinner_app")
def app():
  me.progress_spinner()  # default spinner
  me.progress_spinner(diameter=40, stroke_width=4)
  me.text("Two usages of spinners")
</page>

<page url=''>
from typing import Any, Callable

import mesop.components.box.box_pb2 as box_pb
from mesop.component_helpers import (
  Style,
  insert_composite_component,
  register_event_handler,
  register_native_component,
)
from mesop.events import ClickEvent


@register_native_component
def box(
  *,
  style: Style | None = None,
  on_click: Callable[[ClickEvent], Any] | None = None,
  key: str | None = None,
) -> Any:
  """Creates a box component.

  Args:
    style: Style to apply to component. Follows [HTML Element inline style API](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style).
    on_click: The callback function that is called when the box is clicked.
      It receives a ClickEvent as its only argument.
    key: The component [key](../components/index.md#component-key).

  Returns:
    The created box component.
  """
  return insert_composite_component(
    key=key,
    type_name="box",
    proto=box_pb.BoxType(
      on_click_handler_id=register_event_handler(on_click, event=ClickEvent)
      if on_click
      else "",
    ),
    style=style,
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/box/e2e/box_app")
def app():
  with me.box(style=me.Style(background="red", padding=me.Padding.all(16))):
    with me.box(
      style=me.Style(
        background="green",
        height=50,
        margin=me.Margin.symmetric(vertical=24, horizontal=12),
        border=me.Border.symmetric(
          horizontal=me.BorderSide(width=2, color="pink", style="solid"),
          vertical=me.BorderSide(width=2, color="orange", style="solid"),
        ),
      )
    ):
      me.text(text="hi1")
      me.text(text="hi2")
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Iterable, Literal

import mesop.components.radio.radio_pb2 as radio_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events import MesopEvent


@dataclass(kw_only=True)
class RadioChangeEvent(MesopEvent):
  """Event representing a change in the radio component's value.

  Attributes:
      value: The new value of the radio component after the change.
      key (str): key of the component that emitted this event.
  """

  value: str


register_event_mapper(
  RadioChangeEvent,
  lambda event, key: RadioChangeEvent(key=key.key, value=event.string_value),
)


@dataclass(kw_only=True)
class RadioOption:
  """
  Attributes:
    label: Content to show for the radio option
    value: The value of this radio button.
  """

  label: str | None = None
  value: str | None = None


@register_native_component
def radio(
  *,
  options: Iterable[RadioOption] = (),
  on_change: Callable[[RadioChangeEvent], Any] | None = None,
  color: Literal["primary", "accent", "warn"] | None = None,
  label_position: Literal["before", "after"] = "after",
  value: str = "",
  disabled: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """Creates a Radio component.

  Args:
    options: List of radio options
    on_change: Event emitted when the group value changes. Change events are only emitted when the value changes due to user interaction with a radio button (the same behavior as `<input type-"radio">`).
    color: Theme color for all of the radio buttons in the group.
    label_position: Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
    value: Value for the radio-group. Should equal the value of the selected radio button if there is a corresponding radio button with a matching value.
    disabled: Whether the radio group is disabled.
    style: Style for the component.
    key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="radio",
    proto=radio_pb.RadioType(
      color=color,
      label_position=label_position,
      value=value,
      disabled=disabled,
      on_radio_change_event_handler_id=register_event_handler(
        on_change, event=RadioChangeEvent
      )
      if on_change
      else "",
      options=[
        radio_pb.RadioOption(
          label=option.label,
          value=option.value,
        )
        for option in options
      ],
    ),
    style=style,
  )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  radio_value: str = "2"


def on_change(event: me.RadioChangeEvent):
  s = me.state(State)
  s.radio_value = event.value


@me.page(path="/components/radio/e2e/radio_app")
def app():
  s = me.state(State)
  me.radio(
    on_change=on_change,
    options=[
      me.RadioOption(label="Option 1", value="1"),
      me.RadioOption(label="Option 2", value="2"),
    ],
    value=s.radio_value,
    style=me.Style(
      border=me.Border.all(
        me.BorderSide(
          width=1,
          color="green",
          style="solid",
        )
      )
    ),
  )
  me.text(text="Selected radio value: " + s.radio_value)
</page>

<page url=''>
import base64
from io import BytesIO
from typing import Protocol

from mesop.component_helpers import Style, component
from mesop.components.image.image import image


class Figure(Protocol):
  """
  Provides a minimal interface based on matplotlib's Figure class.
  """

  def savefig(self, fname: BytesIO, *, format: str):
    pass


# Skip pydantic validation because Figure is a Protocol which can't type-check properly
@component(skip_validation=True)
def plot(figure: Figure, *, style: Style | None = None):
  """
  Creates a plot component from a Matplotlib figure.

  Args:
    figure: A [Matplotlib figure](https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure) which will be rendered.
    style: An optional Style object that defines the visual styling for the
      plot component. If None, default styling (e.g. height, width) is used.
  """
  buf = BytesIO()
  figure.savefig(buf, format="svg")
  data = base64.b64encode(buf.getbuffer()).decode("ascii")
  image(src=f"data:image/svg+xml;base64,{data}", style=style)
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Iterable, Literal

import mesop.components.autocomplete.autocomplete_pb2 as autocomplete_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events import InputEvent, MesopEvent


@dataclass(kw_only=True)
class AutocompleteOption:
  """
  Represents an option in the autocomplete drop down.

  Attributes:
    label: Content to show for the autocomplete option
    value: The value of this autocomplete option.
  """

  label: str | None = None
  value: str | None = None


@dataclass(kw_only=True)
class AutocompleteOptionGroup:
  """
  Represents an option group to group options in the autocomplete drop down.

  Attributes:
    label: Group label
    options: Autocomplete options under this group
  """

  label: str
  options: list[AutocompleteOption]


@dataclass(kw_only=True)
class AutocompleteEnterEvent(MesopEvent):
  """Represents an "Enter" keyboard event on an autocomplete component.

  This will return the raw value if `require_selection` is False.

  If `require_selection` is True, then only a valid selection will be returned. An empty
  string will be return if not valid selection has been made.

  Attributes:
    value: Input/selected value.
    key (str): key of the component that emitted this event.
  """

  value: str


register_event_mapper(
  AutocompleteEnterEvent,
  lambda event, key: AutocompleteEnterEvent(
    key=key.key,
    value=event.string_value,
  ),
)


@dataclass(kw_only=True)
class AutocompleteSelectionChangeEvent(MesopEvent):
  """Represents a selection change event.

  Attributes:
      value: Selected value.
      key (str): key of the component that emitted this event.
  """

  value: str


register_event_mapper(
  AutocompleteSelectionChangeEvent,
  lambda userEvent, key: AutocompleteSelectionChangeEvent(
    value=userEvent.string_value,
    key=key.key,
  ),
)


@register_native_component
def autocomplete(
  *,
  options: Iterable[AutocompleteOption | AutocompleteOptionGroup] | None = None,
  label: str = "",
  on_selection_change: Callable[[AutocompleteSelectionChangeEvent], Any]
  | None = None,
  on_input: Callable[[InputEvent], Any] | None = None,
  on_enter: Callable[[AutocompleteEnterEvent], Any] | None = None,
  appearance: Literal["fill", "outline"] = "fill",
  disabled: bool = False,
  placeholder: str = "",
  require_selection: bool = False,
  value: str = "",
  readonly: bool = False,
  hide_required_marker: bool = False,
  color: Literal["primary", "accent", "warn"] = "primary",
  float_label: Literal["always", "auto"] = "auto",
  subscript_sizing: Literal["fixed", "dynamic"] = "fixed",
  hint_label: str = "",
  style: Style | None = None,
  key: str | None = None,
):
  """Creates an autocomplete component.

  Args:
    options: Selectable options from autocomplete.
    label: Label for input.
    on_selection_change: Event emitted when the selected value has been changed by the user.
    on_input: [input](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event) is fired whenever the input has changed (e.g. user types).
    on_enter: triggers when the browser detects an "Enter" key on a [keyup](https://developer.mozilla.org/en-US/docs/Web/API/Element/keyup_event) native browser event.
    appearance: The form field appearance style.
    disabled: Whether it's disabled.
    placeholder: Placeholder value.
    value: Initial value.
    readonly: Whether the element is readonly.
    hide_required_marker: Whether the required marker should be hidden.
    color: The color palette for the form field.
    float_label: Whether the label should always float or float as the user types.
    subscript_sizing: Whether the form field should reserve space for one line of hint/error text (default) or to have the spacing grow from 0px as needed based on the size of the hint/error content. Note that when using dynamic sizing, layout shifts will occur when hint/error text changes.
    hint_label: Text for the form field hint.
    style: Style for input.
    key: The component [key](../components/index.md#component-key).
  """

  insert_component(
    key=key,
    type_name="autocomplete",
    proto=autocomplete_pb.AutocompleteType(
      options=_make_autocomplete_options(options),
      disabled=disabled,
      placeholder=placeholder,
      value=value,
      readonly=readonly,
      hide_required_marker=hide_required_marker,
      color=color,
      float_label=float_label,
      appearance=appearance,
      subscript_sizing=subscript_sizing,
      hint_label=hint_label,
      label=label,
      on_selection_change_handler_id=register_event_handler(
        on_selection_change, event=AutocompleteSelectionChangeEvent
      )
      if on_selection_change
      else "",
      on_input_handler_id=register_event_handler(on_input, event=InputEvent)
      if on_input
      else "",
      on_enter_handler_id=register_event_handler(
        on_enter, event=AutocompleteEnterEvent
      )
      if on_enter
      else "",
    ),
    style=style,
  )


def _make_autocomplete_options(
  options: Iterable[AutocompleteOption | AutocompleteOptionGroup] | None = None,
) -> list[autocomplete_pb.AutocompleteOptionSet]:
  """Converts AutocompleteOption/AutocompleteOptionGroup list to protos."""
  if not options:
    return []

  proto_options = []
  for option in options:
    if isinstance(option, AutocompleteOptionGroup):
      proto_options.append(
        autocomplete_pb.AutocompleteOptionSet(
          option_group=autocomplete_pb.AutocompleteOptionGroup(
            label=option.label,
            options=[
              autocomplete_pb.AutocompleteOption(
                label=sub_option.label, value=sub_option.value
              )
              for sub_option in option.options
            ],
          )
        )
      )
    else:
      proto_options.append(
        autocomplete_pb.AutocompleteOptionSet(
          option=autocomplete_pb.AutocompleteOption(
            label=option.label,
            value=option.value,
          )
        )
      )
  return proto_options
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  raw_value: str
  selected_value: str


@me.page(path="/components/autocomplete/e2e/autocomplete_app")
def app():
  state = me.state(State)

  with me.box(style=me.Style(margin=me.Margin.all(15))):
    me.autocomplete(
      label="Select state",
      options=_make_autocomplete_options(),
      require_selection=True,
      on_selection_change=on_value_change,
      on_enter=on_value_change,
      on_input=on_input,
    )

    if state.selected_value:
      me.text("Selected: " + state.selected_value)


def on_value_change(
  e: me.AutocompleteEnterEvent | me.AutocompleteSelectionChangeEvent,
):
  state = me.state(State)
  state.selected_value = e.value


def on_input(e: me.InputEvent):
  state = me.state(State)
  state.raw_value = e.value


def _make_autocomplete_options() -> list[me.AutocompleteOptionGroup]:
  """Creates and filter autocomplete options.

  The states list assumed to be alphabetized and we group by the first letter of the
  state's name.
  """
  states_options_list = []
  sub_group = None
  for state in _STATES:
    if not sub_group or sub_group.label != state[0]:
      if sub_group:
        states_options_list.append(sub_group)
      sub_group = me.AutocompleteOptionGroup(label=state[0], options=[])
    sub_group.options.append(me.AutocompleteOption(label=state, value=state))
  if sub_group:
    states_options_list.append(sub_group)
  return states_options_list


_STATES = [
  "Alabama",
  "Alaska",
  "Arizona",
  "Arkansas",
  "California",
  "Colorado",
  "Connecticut",
  "Delaware",
  "Florida",
  "Georgia",
  "Hawaii",
  "Idaho",
  "Illinois",
  "Indiana",
  "Iowa",
  "Kansas",
  "Kentucky",
  "Louisiana",
  "Maine",
  "Maryland",
  "Massachusetts",
  "Michigan",
  "Minnesota",
  "Mississippi",
  "Missouri",
  "Montana",
  "Nebraska",
  "Nevada",
  "New Hampshire",
  "New Jersey",
  "New Mexico",
  "New York",
  "North Carolina",
  "North Dakota",
  "Ohio",
  "Oklahoma",
  "Oregon",
  "Pennsylvania",
  "Rhode Island",
  "South Carolina",
  "South Dakota",
  "Tennessee",
  "Texas",
  "Utah",
  "Vermont",
  "Virginia",
  "Washington",
  "West Virginia",
  "Wisconsin",
  "Wyoming",
]
</page>

<page url=''>
from . import autocomplete_app as autocomplete_app
</page>

<page url=''>
import mesop.components.embed.embed_pb2 as embed_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def embed(
  *,
  src: str,
  style: Style | None = None,
  key: str | None = None,
):
  """
  This function creates an embed component.

  Args:
      src: The source URL for the embed content.
      style: The style to apply to the embed, such as width and height.
      key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="embed",
    proto=embed_pb.EmbedType(src=src),
    style=style,
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/embed/e2e/embed_app")
def app():
  state = me.state(State)
  me.button("Switch src url", on_click=switch_src_url)
  me.embed(
    src=state.src_url if state.src_url else "https://google.github.io/mesop/",
    style=me.Style(width="100%", height="100%"),
  )


@me.stateclass
class State:
  src_url: str


def switch_src_url(e: me.ClickEvent):
  state = me.state(State)
  state.src_url = "https://google.github.io/mesop/internal/publishing/"
</page>

<page url=''>
from . import embed_app as embed_app
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Literal

import mesop.components.input.input_pb2 as input_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events import InputEvent, MesopEvent


@dataclass(kw_only=True)
class EnterEvent(MesopEvent):
  """[Deprecated] Represents an "Enter" keyboard event. Use InputEnterEvent instead."""

  pass


@dataclass(kw_only=True)
class InputEnterEvent(MesopEvent):
  """Represents an "Enter" keyboard event on an input component.

  Attributes:
    value: Input value.
    key (str): key of the component that emitted this event.
  """

  value: str


register_event_mapper(
  InputEnterEvent,
  lambda event, key: InputEnterEvent(
    key=key.key,
    value=event.string_value,
  ),
)


@dataclass(kw_only=True)
class InputBlurEvent(MesopEvent):
  """Represents an inpur blur event (when a user loses focus of an input).

  Attributes:
      value: Input value.
      key (str): key of the component that emitted this event.
  """

  value: str


register_event_mapper(
  InputBlurEvent,
  lambda userEvent, key: InputBlurEvent(
    value=userEvent.string_value,
    key=key.key,
  ),
)


@register_native_component
def textarea(
  *,
  label: str = "",
  on_blur: Callable[[InputBlurEvent], Any] | None = None,
  on_input: Callable[[InputEvent], Any] | None = None,
  rows: int = 5,
  autosize: bool = False,
  min_rows: int | None = None,
  max_rows: int | None = None,
  appearance: Literal["fill", "outline"] = "fill",
  style: Style | None = None,
  disabled: bool = False,
  placeholder: str = "",
  required: bool = False,
  value: str = "",
  readonly: bool = False,
  hide_required_marker: bool = False,
  color: Literal["primary", "accent", "warn"] = "primary",
  float_label: Literal["always", "auto"] = "auto",
  subscript_sizing: Literal["fixed", "dynamic"] = "fixed",
  hint_label: str = "",
  key: str | None = None,
):
  """Creates a Textarea component.

  Args:
    label: Label for input.
    on_blur: [blur](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event) is fired when the input has lost focus.
    on_input: [input](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event) is fired whenever the input has changed (e.g. user types). Note: this can cause performance issues. Use `on_blur` instead.
    autosize: If True, the textarea will automatically adjust its height to fit the content, up to the max_rows limit.
    min_rows: The minimum number of rows the textarea will display.
    max_rows: The maximum number of rows the textarea will display.
    rows: The number of lines to show in the text area.
    appearance: The form field appearance style.
    style: Style for input.
    disabled: Whether it's disabled.
    placeholder: Placeholder value
    required: Whether it's required
    value: Initial value.
    readonly: Whether the element is readonly.
    hide_required_marker: Whether the required marker should be hidden.
    color: The color palette for the form field.
    float_label: Whether the label should always float or float as the user types.
    subscript_sizing: Whether the form field should reserve space for one line of hint/error text (default) or to have the spacing grow from 0px as needed based on the size of the hint/error content. Note that when using dynamic sizing, layout shifts will occur when hint/error text changes.
    hint_label: Text for the form field hint.
    key: The component [key](../components/index.md#component-key).
  """

  insert_component(
    key=key,
    type_name="textarea",
    proto=input_pb.InputType(
      rows=rows,
      autosize=autosize,
      min_rows=min_rows,
      max_rows=max_rows,
      is_textarea=True,
      is_native_textarea=False,
      disabled=disabled,
      placeholder=placeholder,
      required=required,
      value=value,
      readonly=readonly,
      hide_required_marker=hide_required_marker,
      color=color,
      float_label=float_label,
      appearance=appearance,
      subscript_sizing=subscript_sizing,
      hint_label=hint_label,
      label=label,
      on_blur_handler_id=register_event_handler(on_blur, event=InputBlurEvent)
      if on_blur
      else "",
      on_input_handler_id=register_event_handler(on_input, event=InputEvent)
      if on_input
      else "",
    ),
    style=style,
  )


@register_native_component
def input(
  *,
  label: str = "",
  on_blur: Callable[[InputBlurEvent], Any] | None = None,
  on_input: Callable[[InputEvent], Any] | None = None,
  on_enter: Callable[[InputEnterEvent], Any] | None = None,
  type: Literal[
    "color",
    "date",
    "datetime-local",
    "email",
    "month",
    "number",
    "password",
    "search",
    "tel",
    "text",
    "time",
    "url",
    "week",
  ]
  | None = None,
  appearance: Literal["fill", "outline"] = "fill",
  style: Style | None = None,
  disabled: bool = False,
  placeholder: str = "",
  required: bool = False,
  value: str = "",
  readonly: bool = False,
  hide_required_marker: bool = False,
  color: Literal["primary", "accent", "warn"] = "primary",
  float_label: Literal["always", "auto"] = "auto",
  subscript_sizing: Literal["fixed", "dynamic"] = "fixed",
  hint_label: str = "",
  key: str | None = None,
):
  """Creates a Input component.

  Args:
    label: Label for input.
    on_blur: [blur](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event) is fired when the input has lost focus.
    on_input: [input](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event) is fired whenever the input has changed (e.g. user types). Note: this can cause performance issues. Use `on_blur` instead.
    on_enter: triggers when the browser detects an "Enter" key on a [keyup](https://developer.mozilla.org/en-US/docs/Web/API/Element/keyup_event) native browser event.
    type: Input type of the element. For textarea, use `me.Textarea(...)`
    appearance: The form field appearance style.
    style: Style for input.
    disabled: Whether it's disabled.
    placeholder: Placeholder value
    required: Whether it's required
    value: Initial value.
    readonly: Whether the element is readonly.
    hide_required_marker: Whether the required marker should be hidden.
    color: The color palette for the form field.
    float_label: Whether the label should always float or float as the user types.
    subscript_sizing: Whether the form field should reserve space for one line of hint/error text (default) or to have the spacing grow from 0px as needed based on the size of the hint/error content. Note that when using dynamic sizing, layout shifts will occur when hint/error text changes.
    hint_label: Text for the form field hint.
    key: The component [key](../components/index.md#component-key).
  """

  insert_component(
    key=key,
    type_name="input",
    proto=input_pb.InputType(
      is_textarea=False,
      is_native_textarea=False,
      disabled=disabled,
      placeholder=placeholder,
      required=required,
      type=type,
      value=value,
      readonly=readonly,
      hide_required_marker=hide_required_marker,
      color=color,
      float_label=float_label,
      appearance=appearance,
      subscript_sizing=subscript_sizing,
      hint_label=hint_label,
      label=label,
      on_blur_handler_id=register_event_handler(on_blur, event=InputBlurEvent)
      if on_blur
      else "",
      on_input_handler_id=register_event_handler(on_input, event=InputEvent)
      if on_input
      else "",
      on_enter_handler_id=register_event_handler(
        on_enter, event=InputEnterEvent
      )
      if on_enter
      else "",
    ),
    style=style,
  )


def native_textarea(
  *,
  on_blur: Callable[[InputBlurEvent], Any] | None = None,
  on_input: Callable[[InputEvent], Any] | None = None,
  autosize: bool = False,
  min_rows: int | None = None,
  max_rows: int | None = None,
  style: Style | None = None,
  disabled: bool = False,
  placeholder: str = "",
  value: str = "",
  readonly: bool = False,
  key: str | None = None,
):
  """Creates a browser native Textarea component. Intended for advanced use cases with maximum UI control.

  Args:
    on_blur: [blur](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event) is fired when the input has lost focus.
    on_input: [input](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event) is fired whenever the input has changed (e.g. user types). Note: this can cause performance issues. Use `on_blur` instead.
    autosize: If True, the textarea will automatically adjust its height to fit the content, up to the max_rows limit.
    min_rows: The minimum number of rows the textarea will display.
    max_rows: The maximum number of rows the textarea will display.
    style: Style for input.
    disabled: Whether it's disabled.
    placeholder: Placeholder value
    value: Initial value.
    readonly: Whether the element is readonly.
    key: The component [key](../components/index.md#component-key).
  """

  insert_component(
    key=key,
    type_name="input",
    proto=input_pb.InputType(
      is_textarea=False,
      is_native_textarea=True,
      autosize=autosize,
      min_rows=min_rows,
      max_rows=max_rows,
      disabled=disabled,
      placeholder=placeholder,
      value=value,
      readonly=readonly,
      on_blur_handler_id=register_event_handler(on_blur, event=InputBlurEvent)
      if on_blur
      else "",
      on_input_handler_id=register_event_handler(on_input, event=InputEvent)
      if on_input
      else "",
    ),
    style=style,
  )
</page>

<page url=''>
from . import input_app as input_app
from . import input_blur_app as input_blur_app
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  input: str = ""


def on_input(e: me.InputEvent):
  state = me.state(State)
  state.input = e.value


def on_enter(e: me.InputEnterEvent):
  state = me.state(State)
  state.input = e.value


@me.page(path="/components/input/e2e/input_app")
def app():
  s = me.state(State)
  me.input(label="Basic input", on_input=on_input)
  me.input(label="Input (on_enter)", on_enter=on_enter)
  me.text(text=s.input)

  me.textarea(
    label="Textarea", on_input=on_input, value="hello world", color="warn"
  )
  me.textarea(
    on_input=on_input,
    placeholder="Placeholder should display automatically when there is no label",
  )
  me.input(
    label="Number input", type="number", on_input=on_input, color="accent"
  )
  me.markdown("# Native input")
  border_side = me.BorderSide(width=0)
  with me.box(
    style=me.Style(
      background="lightblue",
      padding=me.Padding(
        top=16,
        left=16,
        right=16,
        bottom=16,
      ),
    )
  ):
    me.native_textarea(
      readonly=False,
      style=me.Style(
        height=32,
        padding=me.Padding(top=16, right=16, bottom=16, left=16),
        border_radius=16,
        border=me.Border(
          top=border_side,
          right=border_side,
          bottom=border_side,
          left=border_side,
        ),
        outline="none",
      ),
    )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  input: str = ""
  input_value_when_button_clicked: str


def on_blur(e: me.InputBlurEvent):
  state = me.state(State)
  state.input = e.value


def click_button(e: me.ClickEvent):
  state = me.state(State)
  state.input_value_when_button_clicked = state.input


@me.page(path="/components/input/e2e/input_blur_app")
def app():
  s = me.state(State)
  me.input(label="Input", on_blur=on_blur)
  me.button("button", on_click=click_button)
  me.text("Input: " + s.input)
  me.text(
    "input_value_when_button_clicked: " + s.input_value_when_button_clicked
  )

  me.textarea(label="Regular textarea", on_blur=on_blur, value="hello world")

  me.native_textarea(on_blur=on_blur)
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Literal

import mesop.components.progress_bar.progress_bar_pb2 as progress_bar_pb
from mesop.component_helpers import (
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events import MesopEvent


@dataclass(kw_only=True)
class ProgressBarAnimationEndEvent(MesopEvent):
  """
  Event emitted when the animation of the progress bar ends.

  Attributes:
      value: The value of the progress bar when the animation ends.
      key (str): Key of the component that emitted this event.
  """

  value: float


register_event_mapper(
  ProgressBarAnimationEndEvent,
  lambda event, key: ProgressBarAnimationEndEvent(
    key=key.key,
    value=event.double_value,
  ),
)


@register_native_component
def progress_bar(
  *,
  key: str | None = None,
  color: Literal["primary", "accent", "warn"] | None = None,
  value: float = 0,
  buffer_value: float = 0,
  mode: Literal[
    "determinate", "indeterminate", "buffer", "query"
  ] = "indeterminate",
  on_animation_end: Callable[[ProgressBarAnimationEndEvent], Any] | None = None,
):
  """Creates a Progress bar component.

  Args:
    key: The component [key](../components/index.md#component-key).
    color: Theme palette color of the progress bar.
    value: Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow.
    buffer_value: Buffer value of the progress bar. Defaults to zero.
    mode: Mode of the progress bar. Input must be one of these values: determinate, indeterminate, buffer, query, defaults to 'determinate'. Mirrored to mode attribute.
    on_animation_end: Event emitted when animation of the primary progress bar completes. This event will not be emitted when animations are disabled, nor will it be emitted for modes with continuous animations (indeterminate and query).
  """
  insert_component(
    key=key,
    type_name="progress_bar",
    proto=progress_bar_pb.ProgressBarType(
      color=color,
      value=value,
      buffer_value=buffer_value,
      mode=mode,
      on_progress_bar_animation_end_event_handler_id=register_event_handler(
        on_animation_end, event=ProgressBarAnimationEndEvent
      )
      if on_animation_end
      else "",
    ),
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/progress_bar/e2e/progress_bar_app")
def app():
  me.text(text="Hello, world!")
  me.progress_bar(mode="indeterminate")
</page>

<page url=''>
from . import progress_bar_app as progress_bar_app
</page>

<page url=''>
import markdown as markdown_lib
from markdown.extensions.codehilite import CodeHiliteExtension

import mesop.components.markdown.markdown_pb2 as markdown_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def markdown(
  text: str | None = None,
  *,
  style: Style | None = None,
  key: str | None = None,
):
  """
  This function creates a markdown.

  Args:
      text: **Required.** Markdown text
      style: Style to apply to component. Follows [HTML Element inline style API](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style).
  """

  if text:
    html = markdown_lib.markdown(
      text,
      extensions=[
        "attr_list",
        "tables",
        CodeHiliteExtension(css_class="highlight"),
        "fenced_code",
      ],
    )
  else:
    html = ""
  insert_component(
    key=key,
    type_name="markdown",
    style=style,
    proto=markdown_pb.MarkdownType(
      html=html,
    ),
  )
</page>

<page url=''>
from . import markdown_app as markdown_app
</page>

<page url=''>
import mesop as me

SAMPLE_MARKDOWN = """
# Sample Markdown Document

Regular code block:

```
hello
```

Python code block:

Syntax 1:

```python
def foo():
  print("Hello, World!")

foo()
```

Syntax 2:

``` python
def foo():
  print("Hello, World!")

foo()
```

## Table of Contents
1. [Headers](#headers)
2. [Emphasis](#emphasis)
3. [Lists](#lists)
4. [Links](#links)
5. [Code](#code)
6. [Blockquotes](#blockquotes)
7. [Tables](#tables)
8. [Horizontal Rules](#horizontal-rules)

## Headers
# Header 1
## Header 2
### Header 3
#### Header 4
##### Header 5
###### Header 6

## Emphasis
*Italic text* or _Italic text_
**Bold text** or __Bold text__
***Bold and Italic*** or ___Bold and Italic___

## Lists

### Unordered List
- Item 1
- Item 2
  - Subitem 2.1
  - Subitem 2.2

### Ordered List
1. First item
2. Second item
   1. Subitem 2.1
   2. Subitem 2.2

## Links
[Google](https://www.google.com/)

## Code
Inline `code`

## Table

First Header  | Second Header
------------- | -------------
Content Cell { .foo }  | Content Cell { .foo }
Content Cell { .bar } | Content Cell { .bar }
"""


@me.page(path="/components/markdown/e2e/markdown_app")
def app():
  me.markdown(
    text=SAMPLE_MARKDOWN,
    style=me.Style(
      margin=me.Margin.all(4),
      border=me.Border.all(
        me.BorderSide(width=2, color="pink", style="solid"),
      ),
    ),
  )
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Literal

import mesop.components.checkbox.checkbox_pb2 as checkbox_pb
from mesop.component_helpers import (
  Style,
  component,
  insert_composite_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.components.text.text import text
from mesop.events import MesopEvent


@dataclass(kw_only=True)
class CheckboxChangeEvent(MesopEvent):
  """Represents a checkbox state change event.

  Attributes:
      checked: The new checked state of the checkbox.
      key (str): key of the component that emitted this event.
  """

  checked: bool


register_event_mapper(
  CheckboxChangeEvent,
  lambda event, key: CheckboxChangeEvent(
    key=key.key,
    checked=event.bool_value,
  ),
)


@dataclass(kw_only=True)
class CheckboxIndeterminateChangeEvent(MesopEvent):
  """Represents a checkbox indeterminate state change event.

  Attributes:
      checked: The new indeterminate state of the checkbox.
      key (str): key of the component that emitted this event.
  """

  indeterminate: bool


register_event_mapper(
  CheckboxIndeterminateChangeEvent,
  lambda event, key: CheckboxIndeterminateChangeEvent(
    key=key.key,
    indeterminate=event.bool_value,
  ),
)


@component
def checkbox(
  label: str | None = None,
  *,
  on_change: Callable[[CheckboxChangeEvent], Any] | None = None,
  on_indeterminate_change: Callable[[CheckboxIndeterminateChangeEvent], Any]
  | None = None,
  label_position: Literal["before", "after"] = "after",
  disable_ripple: bool = False,
  tab_index: int = 0,
  color: Literal["primary", "accent", "warn"] | None = None,
  checked: bool = False,
  disabled: bool = False,
  indeterminate: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """Creates a simple Checkbox component with a text label.

  Args:
    label: Text label for checkbox
    on_change: Event emitted when the checkbox's `checked` value changes.
    on_indeterminate_change: Event emitted when the checkbox's `indeterminate` value changes.
    label_position: Whether the label should appear after or before the checkbox. Defaults to 'after'
    disable_ripple: Whether the checkbox has a ripple.
    tab_index: Tabindex for the checkbox.
    color: Palette color of the checkbox.
    checked: Whether the checkbox is checked.
    disabled: Whether the checkbox is disabled.
    indeterminate: Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to represent a checkbox with three states, e.g. a checkbox that represents a nested list of checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately set to false.
    style: Style for the component.
    key: The component [key](../components/index.md#component-key).
  """
  with content_checkbox(
    on_change=on_change,
    on_indeterminate_change=on_indeterminate_change,
    label_position=label_position,
    disable_ripple=disable_ripple,
    tab_index=tab_index,
    color=color,
    checked=checked,
    disabled=disabled,
    indeterminate=indeterminate,
    style=style,
    key=key,
  ):
    text(label)


@register_native_component
def content_checkbox(
  *,
  on_change: Callable[[CheckboxChangeEvent], Any] | None = None,
  on_indeterminate_change: Callable[[CheckboxIndeterminateChangeEvent], Any]
  | None = None,
  label_position: Literal["before", "after"] = "after",
  disable_ripple: bool = False,
  tab_index: int = 0,
  color: Literal["primary", "accent", "warn"] | None = None,
  checked: bool = False,
  disabled: bool = False,
  indeterminate: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """Creates a Checkbox component which is a composite component. Typically, you would use a text or icon component as a child.

  Intended for advanced use cases.

  Args:
    on_change: Event emitted when the checkbox's `checked` value changes.
    on_indeterminate_change: Event emitted when the checkbox's `indeterminate` value changes.
    label_position: Whether the label should appear after or before the checkbox. Defaults to 'after'
    disable_ripple: Whether the checkbox has a ripple.
    tab_index: Tabindex for the checkbox.
    color: Palette color of the checkbox.
    checked: Whether the checkbox is checked.
    disabled: Whether the checkbox is disabled.
    indeterminate: Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to represent a checkbox with three states, e.g. a checkbox that represents a nested list of checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately set to false.
    style: Style for the component.
    key: The component [key](../components/index.md#component-key).
  """
  return insert_composite_component(
    key=key,
    type_name="content_checkbox",
    proto=checkbox_pb.CheckboxType(
      label_position=label_position,
      disable_ripple=disable_ripple,
      tab_index=tab_index,
      color=color,
      checked=checked,
      disabled=disabled,
      indeterminate=indeterminate,
      on_checkbox_change_event_handler_id=register_event_handler(
        on_change, event=CheckboxChangeEvent
      )
      if on_change
      else "",
      on_checkbox_indeterminate_change_event_handler_id=register_event_handler(
        on_indeterminate_change, event=CheckboxIndeterminateChangeEvent
      )
      if on_indeterminate_change
      else "",
    ),
    style=style,
  )
</page>

<page url=''>
from . import checkbox_app as checkbox_app
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  checked: bool = True
  indeterminate: bool = True


def on_update(event: me.CheckboxChangeEvent):
  state = me.state(State)
  state.checked = event.checked


@me.page(path="/components/checkbox/e2e/checkbox_app")
def app():
  state = me.state(State)
  me.checkbox(
    "label",
    on_change=on_update,
    checked=state.checked,
    disable_ripple=False,
    indeterminate=False,
    style=me.Style(
      border=me.Border.all(
        me.BorderSide(
          width=1,
          color="green",
          style="solid",
        )
      )
    ),
  )

  if state.checked:
    me.text(text="is checked")
  else:
    me.text(text="is not checked")
</page>

<page url=''>
from mesop.component_helpers import component
from mesop.components.markdown.markdown import markdown


@component
def code(code: str = "", *, language: str = "python"):
  """
  Creates a code component which displays code with syntax highlighting.
  """
  markdown("``` " + language + "\n" + code + "\n" + "```")
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Literal

import mesop.components.slider.slider_pb2 as slider_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events.events import MesopEvent


@dataclass(kw_only=True)
class SliderValueChangeEvent(MesopEvent):
  """
  Event triggered when the slider value changes.

  Attributes:
      value: The new value of the slider after the change.
      key (str): Key of the component that emitted this event.
  """

  value: float


register_event_mapper(
  SliderValueChangeEvent,
  lambda event, key: SliderValueChangeEvent(
    key=key.key,
    value=event.double_value,
  ),
)


@register_native_component
def slider(
  *,
  on_value_change: Callable[[SliderValueChangeEvent], Any] | None = None,
  value: float | None = None,
  min: float = 0,
  max: float = 100,
  step: float = 1,
  color: Literal["primary", "accent", "warn"] = "primary",
  disabled: bool = False,
  discrete: bool = False,
  show_tick_marks: bool = False,
  disable_ripple: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """Creates a Slider component.

  Args:
    on_value_change: An event will be dispatched each time the slider changes its value.
    value: Initial value. If updated, the slider will be updated with a new initial value.
    min: The minimum value that the slider can have.
    max: The maximum value that the slider can have.
    step: The values at which the thumb will snap.
    disabled: Whether the slider is disabled.
    discrete: Whether the slider displays a numeric value label upon pressing the thumb.
    show_tick_marks: Whether the slider displays tick marks along the slider track.
    color: Palette color of the slider.
    disable_ripple: Whether ripples are disabled in the slider.
    style: Style for the component.
    key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="slider",
    style=style,
    proto=slider_pb.SliderType(
      disabled=disabled,
      discrete=discrete,
      show_tick_marks=show_tick_marks,
      value=value if value is not None else min,
      min=min,
      color=color,
      disable_ripple=disable_ripple,
      max=max,
      step=step,
      on_value_change_handler_id=register_event_handler(
        on_value_change, SliderValueChangeEvent
      )
      if on_value_change
      else "",
    ),
  )
</page>

<page url=''>
from . import slider_app as slider_app
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  initial_value: float = 50.0
  value: float = 50.0


def on_value_change(event: me.SliderValueChangeEvent):
  me.state(State).value = event.value


def on_input(event: me.InputEvent):
  state = me.state(State)
  state.initial_value = float(event.value)
  state.value = state.initial_value


@me.page(path="/components/slider/e2e/slider_app")
def app():
  state = me.state(State)
  me.input(label="Slider value", on_input=on_input)
  me.slider(
    on_value_change=on_value_change,
    value=state.initial_value,
    style=me.Style(width="100%"),
  )
  me.text(text=f"Value: {me.state(State).value}")
</page>

<page url=''>
from typing import Literal

import mesop.components.html.html_pb2 as html_pb
from mesop.component_helpers import (
  Border,
  BorderSide,
  Style,
  insert_component,
  register_native_component,
)
from mesop.warn import warn


@register_native_component
def html(
  html: str = "",
  *,
  mode: Literal["sanitized", "sandboxed"] | None = None,
  style: Style | None = None,
  key: str | None = None,
):
  """
  This function renders custom HTML in a secure way.

  Args:
      html: The HTML content to be rendered.
      mode: Determines how the HTML is rendered. Mode can be either "sanitized" or "sandboxed".
          If "sanitized" then potentially dangerous content like `<script>` and `<style>` are
          stripped out. If "sandboxed", then all content is allowed, but rendered in an iframe for isolation.
      style: The style to apply to the embed, such as width and height.
      key: The component [key](../components/index.md#component-key).
  """
  if mode != "sandboxed" and (
    any(
      activeContent in html
      for activeContent in ("<script>", "<style>", "style=")
    )
  ):
    warn(
      "Javascript or Stylesheets were sanitized from me.html. Use me.html(mode='sandboxed') instead."
    )
  if style is None:
    style = Style()
  if style.border is None:
    style.border = Border.all(
      BorderSide(
        width=0,
      )
    )
  insert_component(
    key=key,
    type_name="html",
    proto=html_pb.HtmlType(
      html=html,
      mode=mode,
    ),
    style=style,
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/html/e2e/html_large_app")
def app():
  me.html(HTML, mode="sandboxed", style=me.Style(height=400, width=830))


HTML = """<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Miles_per_Gallon</th>
      <th>Cylinders</th>
      <th>Displacement</th>
      <th>Horsepower</th>
      <th>Weight_in_lbs</th>
      <th>Acceleration</th>
      <th>Year</th>
      <th>Origin</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>chevrolet chevelle malibu</td>
      <td>18.0</td>
      <td>8</td>
      <td>307.0</td>
      <td>130.0</td>
      <td>3504</td>
      <td>12.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>1</th>
      <td>buick skylark 320</td>
      <td>15.0</td>
      <td>8</td>
      <td>350.0</td>
      <td>165.0</td>
      <td>3693</td>
      <td>11.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>2</th>
      <td>plymouth satellite</td>
      <td>18.0</td>
      <td>8</td>
      <td>318.0</td>
      <td>150.0</td>
      <td>3436</td>
      <td>11.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>3</th>
      <td>amc rebel sst</td>
      <td>16.0</td>
      <td>8</td>
      <td>304.0</td>
      <td>150.0</td>
      <td>3433</td>
      <td>12.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ford torino</td>
      <td>17.0</td>
      <td>8</td>
      <td>302.0</td>
      <td>140.0</td>
      <td>3449</td>
      <td>10.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>5</th>
      <td>ford galaxie 500</td>
      <td>15.0</td>
      <td>8</td>
      <td>429.0</td>
      <td>198.0</td>
      <td>4341</td>
      <td>10.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>6</th>
      <td>chevrolet impala</td>
      <td>14.0</td>
      <td>8</td>
      <td>454.0</td>
      <td>220.0</td>
      <td>4354</td>
      <td>9.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>7</th>
      <td>plymouth fury iii</td>
      <td>14.0</td>
      <td>8</td>
      <td>440.0</td>
      <td>215.0</td>
      <td>4312</td>
      <td>8.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>8</th>
      <td>pontiac catalina</td>
      <td>14.0</td>
      <td>8</td>
      <td>455.0</td>
      <td>225.0</td>
      <td>4425</td>
      <td>10.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>9</th>
      <td>amc ambassador dpl</td>
      <td>15.0</td>
      <td>8</td>
      <td>390.0</td>
      <td>190.0</td>
      <td>3850</td>
      <td>8.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>10</th>
      <td>citroen ds-21 pallas</td>
      <td>NaN</td>
      <td>4</td>
      <td>133.0</td>
      <td>115.0</td>
      <td>3090</td>
      <td>17.5</td>
      <td>1970-01-01</td>
      <td>Europe</td>
    </tr>
    <tr>
      <th>11</th>
      <td>chevrolet chevelle concours (sw)</td>
      <td>NaN</td>
      <td>8</td>
      <td>350.0</td>
      <td>165.0</td>
      <td>4142</td>
      <td>11.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>12</th>
      <td>ford torino (sw)</td>
      <td>NaN</td>
      <td>8</td>
      <td>351.0</td>
      <td>153.0</td>
      <td>4034</td>
      <td>11.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>13</th>
      <td>plymouth satellite (sw)</td>
      <td>NaN</td>
      <td>8</td>
      <td>383.0</td>
      <td>175.0</td>
      <td>4166</td>
      <td>10.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>14</th>
      <td>amc rebel sst (sw)</td>
      <td>NaN</td>
      <td>8</td>
      <td>360.0</td>
      <td>175.0</td>
      <td>3850</td>
      <td>11.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>15</th>
      <td>dodge challenger se</td>
      <td>15.0</td>
      <td>8</td>
      <td>383.0</td>
      <td>170.0</td>
      <td>3563</td>
      <td>10.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>16</th>
      <td>plymouth 'cuda 340</td>
      <td>14.0</td>
      <td>8</td>
      <td>340.0</td>
      <td>160.0</td>
      <td>3609</td>
      <td>8.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>17</th>
      <td>ford mustang boss 302</td>
      <td>NaN</td>
      <td>8</td>
      <td>302.0</td>
      <td>140.0</td>
      <td>3353</td>
      <td>8.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>18</th>
      <td>chevrolet monte carlo</td>
      <td>15.0</td>
      <td>8</td>
      <td>400.0</td>
      <td>150.0</td>
      <td>3761</td>
      <td>9.5</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
    <tr>
      <th>19</th>
      <td>buick estate wagon (sw)</td>
      <td>14.0</td>
      <td>8</td>
      <td>455.0</td>
      <td>225.0</td>
      <td>3086</td>
      <td>10.0</td>
      <td>1970-01-01</td>
      <td>USA</td>
    </tr>
  </tbody>
</table>"""
</page>

<page url=''>
from . import html_app as html_app
from . import html_default_app as html_default_app
from . import html_large_app as html_large_app
from . import html_origin_app as html_origin_app
</page>

<page url=''>
import mesop as me


@me.page(path="/components/html/e2e/html_origin_app")
def app():
  me.html(
    """<body>
      <script>document.body.innerHTML="origin: " + window.location.origin</script>
      </body>""",
    mode="sandboxed",
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/html/e2e/html_app")
def app():
  s = me.state(State)

  me.text("Sanitized HTML")
  me.html(
    """
Custom HTML
<a href="https://google.github.io/mesop/" target="_blank">mesoplink</a>
""",
    mode="sanitized",
  )
  with me.box(style=me.Style(margin=me.Margin.symmetric(vertical=24))):
    me.divider()
  me.text("Sandboxed HTML")
  me.button("Increment sandboxed HTML", on_click=increment_sandboxed_html)
  me.html(
    f"iamsandboxed-{s.counter}<script>console.log('iamsandboxed-{s.counter}'); </script>",
    mode="sandboxed",
  )


@me.stateclass
class State:
  counter: int


def increment_sandboxed_html(e: me.ClickEvent):
  s = me.state(State)
  s.counter += 1
</page>

<page url=''>
import mesop as me


@me.page(path="/components/html/e2e/html_default_app")
def app():
  me.html("i am <a href='#'>sanitized</a>")
  me.html(
    """<body><script>document.body.innerHTML='iamsandboxed'</script></body>"""
  )
</page>

<page url=''>
import mesop.components.image.image_pb2 as image_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def image(
  *,
  src: str | None = None,
  alt: str | None = None,
  style: Style | None = None,
  key: str | None = None,
):
  """
  This function creates an image component.

  Args:
      src: The source URL of the image.
      alt: The alternative text for the image if it cannot be displayed.
      style: The style to apply to the image, such as width and height.
      key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="image",
    proto=image_pb.ImageType(
      src=src,
      alt=alt,
    ),
    style=style,
  )
</page>

<page url=''>
from . import image_app as image_app
</page>

<page url=''>
import mesop as me


@me.page(path="/components/image/e2e/image_app")
def app():
  me.image(
    src="https://interactive-examples.mdn.mozilla.net/media/cc0-images/grapefruit-slice-332-332.jpg",
    alt="Grapefruit",
    style=me.Style(width="150px", height="150px"),
  )
</page>

<page url=''>
import mesop.components.audio.audio_pb2 as audio_pb
from mesop.component_helpers import insert_component, register_native_component


@register_native_component
def audio(
  *, src: str | None = None, key: str | None = None, autoplay: bool = False
):
  """
  Creates an audio component.

  Args:
      src: The URL of the audio to be played.
      autoplay: boolean value indicating if the audio should be autoplayed or not. **Note**: There are autoplay restrictions in modern browsers, including Chrome, are designed to prevent audio or video from playing automatically without user interaction. This is intended to improve user experience and reduce unwanted interruptions
      key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="audio",
    proto=audio_pb.AudioType(src=src, autoplay=autoplay),
  )
</page>

<page url=''>
from . import audio_app as audio_app
</page>

<page url=''>
import mesop as me


@me.page(path="/components/audio/e2e/audio_app")
def app():
  me.audio(
    src="https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3",
  )
</page>

<page url=''>
from typing import Any, Callable, Literal

import mesop.components.button.button_pb2 as button_pb
from mesop.component_helpers import (
  Style,
  component,
  insert_composite_component,
  register_event_handler,
  register_native_component,
)
from mesop.components.text.text import text
from mesop.events import ClickEvent


@component
def button(
  label: str | None = None,
  *,
  on_click: Callable[[ClickEvent], Any] | None = None,
  type: Literal["raised", "flat", "stroked"] | None = None,
  color: Literal["primary", "accent", "warn"] | None = None,
  disable_ripple: bool = False,
  disabled: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """Creates a simple text Button component.

  Args:
    label: Text label for button
    on_click: [click](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click_event) is a native browser event.
    type: Type of button style to use
    color: Theme color palette of the button
    disable_ripple: Whether the ripple effect is disabled or not.
    disabled: Whether the button is disabled.
    style: Style for the component.
    key: The component [key](../components/index.md#component-key).
  """
  with content_button(
    on_click=on_click,
    type=type,
    color=color,
    disable_ripple=disable_ripple,
    disabled=disabled,
    style=style,
    key=key,
  ):
    text(label)


@register_native_component
def content_button(
  *,
  on_click: Callable[[ClickEvent], Any] | None = None,
  type: Literal["raised", "flat", "stroked", "icon"] | None = None,
  color: Literal["primary", "accent", "warn"] | None = None,
  disable_ripple: bool = False,
  disabled: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """Creates a button component, which is a composite component. Typically, you would use a text or icon component as a child.

  Intended for advanced use cases.

  Args:
    on_click: [click](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click_event) is a native browser event.
    type: Type of button style to use
    color: Theme color palette of the button
    disable_ripple: Whether the ripple effect is disabled or not.
    disabled: Whether the button is disabled.
    style: Style for the component.
    key: The component [key](../components/index.md#component-key).
  """
  return insert_composite_component(
    key=key,
    type_name="content_button",
    proto=button_pb.ButtonType(
      color=color,
      disable_ripple=disable_ripple,
      disabled=disabled,
      on_click_handler_id=register_event_handler(on_click, event=ClickEvent)
      if on_click
      else "",
      type_index=_get_type_index(type),
      type=type,
    ),
    style=style,
  )


def _get_type_index(
  type: Literal["raised", "flat", "stroked", "icon"] | None,
) -> int:
  if type is None:
    return 0
  if type == "raised":
    return 1
  if type == "flat":
    return 2
  if type == "stroked":
    return 3
  if type == "icon":
    return 4
  raise Exception("Unexpected type: " + type)
</page>

<page url=''>
import mesop.components.link.link_pb2 as link_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def link(
  *,
  text: str,
  url: str,
  open_in_new_tab: bool = False,
  style: Style | None = None,
  key: str | None = None,
):
  """
  This function creates a link.

  Args:
      text: The text to be displayed.
      url: The URL to navigate to.
      open_in_new_tab: If True, open page in new tab. If False, open page in current tab.
      style: Style for the component. Defaults to None.
      key: Unique key for the component. Defaults to None.
  """
  insert_component(
    key=key,
    style=style,
    type_name="link",
    proto=link_pb.LinkType(
      target="_blank" if open_in_new_tab else "_self",
      text=text,
      url=url,
    ),
  )
</page>

<page url=''>
from . import link_app as link_app
</page>

<page url=''>
import mesop as me


@me.page(path="/components/link/e2e/link_app")
def app():
  me.link(text="Open in same tab", url="https://google.com")
  me.link(
    text="Styled link: Google",
    url="https://google.com",
    style=me.Style(color="black", text_decoration="none"),
  )
  me.link(
    text="Open in new tab",
    open_in_new_tab=True,
    url="https://google.com",
  )
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable

import mesop.components.table.table_pb2 as table_pb
from mesop.component_helpers import (
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events import MesopEvent


@dataclass(kw_only=True)
class TableClickEvent(MesopEvent):
  """Event representing a click on the table component cell.

  Attributes:
      row_index: DataFrame row index of the clicked cell in the table.
      col_index: DataFrame col index of the clicked cell in the table.
      key (str): key of the component that emitted this event.
  """

  row_index: int
  col_index: int


def map_table_click_event(event, key):
  click_event = table_pb.TableClickEvent()
  click_event.ParseFromString(event.bytes_value)
  return TableClickEvent(
    key=key.key,
    row_index=click_event.row_index,
    col_index=click_event.col_index,
  )


register_event_mapper(TableClickEvent, map_table_click_event)


@dataclass(kw_only=True)
class TableHeader:
  sticky: bool = False


@dataclass(kw_only=True)
class TableColumn:
  sticky: bool = False


# Don't include type hint since Pydantic can't properly type check the Pandas data
# frame. In addition, we don't want to include Pandas as a dependency into Mesop.
@register_native_component
def table(
  data_frame: Any,
  *,
  on_click: Callable[[TableClickEvent], Any] | None = None,
  header: TableHeader | None = None,
  columns: dict[str, TableColumn] | None = None,
):
  """
  This function creates a table from Pandas data frame

  Args:
      data_frame: Pandas data frame.
      on_click: Triggered when a table cell is clicked. The [click event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click_event) is a native browser event.
      header: Configures table header to be sticky or not.
      columns: Configures table columns to be sticky or not. The key is the name of the column.
  """
  if not columns:
    columns = {}
  if not header:
    header = TableHeader()
  insert_component(
    type_name="table",
    proto=table_pb.TableType(
      displayed_columns=list(data_frame.columns),
      data_source=_to_data_source(data_frame),
      on_table_click_event_handler_id=register_event_handler(
        on_click, event=TableClickEvent
      )
      if on_click
      else "",
      header=table_pb.TableHeader(sticky=header.sticky),
      columns={
        column_name: table_pb.TableColumn(sticky=column.sticky)
        for column_name, column in columns.items()
      },
    ),
  )


def _to_data_source(data_frame) -> list[table_pb.TableRow]:
  """Convert Pandas data frame for display as a table.

  All values will be converted to strings for display purposes on the frontend.

  The special Pandas `Index` column is included automatically, so we can refer back to
  same cell on the server to handle user events.
  """
  data = []
  for df_row in data_frame.itertuples(name=None):
    data.append(
      table_pb.TableRow(
        index=df_row[0],
        cell_values=[str(row) for row in df_row[1:]],
      )
    )
  return data
</page>

<page url=''>
from . import table_app as table_app
</page>

<page url=''>
from datetime import datetime

import numpy as np
import pandas as pd

import mesop as me


@me.stateclass
class State:
  selected_cell: str = "No cell selected."


df = pd.DataFrame(
  data={
    "NA": [pd.NA, pd.NA, pd.NA],
    "Index": [3, 2, 1],
    "Bools": [True, False, np.bool_(True)],
    "Ints": [101, 90, np.int64(-55)],
    "Floats": [2.3, 4.5, np.float64(-3.000000003)],
    "Strings": ["Hello", "World", "!"],
    "Date Times": [
      pd.Timestamp("20180310"),
      pd.Timestamp("20230310"),
      datetime(2023, 1, 1, 12, 12, 1),
    ],
  }
)


@me.page(path="/components/table/e2e/table_app")
def app():
  state = me.state(State)

  with me.box(style=me.Style(padding=me.Padding.all(10), width=500)):
    me.table(
      df,
      on_click=on_click,
      header=me.TableHeader(sticky=True),
      columns={
        "NA": me.TableColumn(sticky=True),
        "Index": me.TableColumn(sticky=True),
      },
    )

  with me.box(
    style=me.Style(
      background="#ececec",
      margin=me.Margin.all(10),
      padding=me.Padding.all(10),
    )
  ):
    me.text(state.selected_cell)


def on_click(e: me.TableClickEvent):
  state = me.state(State)
  state.selected_cell = (
    f"Selected cell at col {e.col_index} and row {e.row_index} "
    f"with value {df.iat[e.row_index, e.col_index]!s}"
  )
</page>

<page url=''>
import mesop.components.divider.divider_pb2 as divider_pb
from mesop.component_helpers import (
  insert_component,
  register_native_component,
)


@register_native_component
def divider(*, key: str | None = None, inset: bool = False):
  """Creates a Divider component.

  Args:
    key: The component [key](../components/index.md#component-key).
    inset: Whether the divider is an inset divider.
  """
  insert_component(
    key=key,
    type_name="divider",
    proto=divider_pb.DividerType(inset=inset),
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/divider/e2e/divider_app")
def app():
  me.text(text="before")
  me.divider()
  me.text(text="after")
</page>

<page url=''>
from . import divider_app as divider_app
</page>

<page url=''>
from typing import Literal

import mesop.components.text.text_pb2 as text_pb2
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def text(
  text: str | None = None,
  *,
  type: Literal[
    "headline-1",
    "headline-2",
    "headline-3",
    "headline-4",
    "headline-5",
    "headline-6",
    "subtitle-1",
    "subtitle-2",
    "body-1",
    "body-2",
    "caption",
    "button",
  ]
  | None = None,
  style: Style | None = None,
  key: str | None = None,
):
  """
  Create a text component.

  Args:
      text: The text to display.
      type: The typography level for the text.
      style: Style to apply to component. Follows [HTML Element inline style API](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style).
      key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="text",
    proto=text_pb2.TextType(
      text=text,
      type=type,
    ),
    style=style,
  )
</page>

<page url=''>
from . import text_app as text_app
</page>

<page url=''>
import mesop as me


@me.page(path="/components/text/e2e/text_app")
def text():
  me.text(text="H1: Hello, world!", type="headline-1")
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Iterable

import mesop.components.select.select_pb2 as select_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.events import MesopEvent


@dataclass(kw_only=True)
class SelectOpenedChangeEvent(MesopEvent):
  """Event representing the opened state change of the select component.

  Attributes:
      opened: A boolean indicating whether the select component is opened (True) or closed (False).
      key (str): key of the component that emitted this event.
  """

  opened: bool


register_event_mapper(
  SelectOpenedChangeEvent,
  lambda event, key: SelectOpenedChangeEvent(
    key=key.key,
    opened=event.bool_value,
  ),
)


@dataclass(kw_only=True)
class SelectSelectionChangeEvent(MesopEvent):
  """Event representing a change in the select component's value(s).

  Attributes:
      values: New values of the select component after the change.
      key (str): Key of the component that emitted this event.
  """

  values: list[str]

  @property
  def value(self):
    """Shortcut for returning a single value."""
    if not self.values:
      return ""
    return self.values[0]


def map_select_change_event(event, key):
  select_event = select_pb.SelectChangeEvent()
  select_event.ParseFromString(event.bytes_value)
  return SelectSelectionChangeEvent(
    key=key.key,
    values=list(select_event.values),
  )


register_event_mapper(SelectSelectionChangeEvent, map_select_change_event)


@dataclass(kw_only=True)
class SelectOption:
  """Represents an option within a select component.

  Attributes:
      label: The content shown for the select option.
      value: The value associated with the select option.
  """

  label: str | None = None
  value: str | None = None


@register_native_component
def select(
  *,
  options: Iterable[SelectOption] = (),
  on_selection_change: Callable[[SelectSelectionChangeEvent], Any]
  | None = None,
  on_opened_change: Callable[[SelectOpenedChangeEvent], Any] | None = None,
  key: str | None = None,
  label: str = "",
  disabled: bool = False,
  disable_ripple: bool = False,
  tab_index: int = 0,
  placeholder: str = "",
  value: str = "",
  style: Style | None = None,
  multiple: bool = False,
):
  """Creates a Select component.

  Args:
    options: List of select options.
    on_selection_change: Event emitted when the selected value has been changed by the user.
    on_opened_change: Event emitted when the select panel has been toggled.
    disabled: Whether the select is disabled.
    disable_ripple: Whether ripples in the select are disabled.
    multiple: Whether multiple selections are allowed.
    tab_index: Tab index of the select.
    placeholder: Placeholder to be shown if no value has been selected.
    value: Value of the select control.
    style: Style.
    key: The component [key](../components/index.md#component-key).
  """
  insert_component(
    key=key,
    type_name="select",
    style=style,
    proto=select_pb.SelectType(
      options=[
        select_pb.SelectOption(label=option.label, value=option.value)
        for option in options
      ],
      label=label,
      disabled=disabled,
      disable_ripple=disable_ripple,
      multiple=multiple,
      tab_index=tab_index,
      placeholder=placeholder,
      value=value,
      on_select_opened_change_event_handler_id=register_event_handler(
        on_opened_change, event=SelectOpenedChangeEvent
      )
      if on_opened_change
      else "",
      on_select_selection_change_event_handler_id=register_event_handler(
        on_selection_change, event=SelectSelectionChangeEvent
      )
      if on_selection_change
      else "",
    ),
  )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  selected_value: str = ""


def on_selection_change(e: me.SelectSelectionChangeEvent):
  s = me.state(State)
  s.selected_value = e.value


@me.page(path="/components/select/e2e/select_app")
def app():
  me.text(text="Select")
  me.select(
    label="Select",
    options=[
      me.SelectOption(label="label 1", value="value1"),
      me.SelectOption(label="label 2", value="value2"),
      me.SelectOption(label="label 3", value="value3"),
    ],
    on_selection_change=on_selection_change,
    style=me.Style(width=500),
  )
  s = me.state(State)
  me.text(text="Selected value: " + s.selected_value)
</page>

<page url=''>
from . import select_app as select_app
from . import select_app_multiple as select_app_multiple
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  selected_values: list[str]


def on_selection_change(e: me.SelectSelectionChangeEvent):
  s = me.state(State)
  s.selected_values = e.values


@me.page(path="/components/select/e2e/select_app_multiple")
def app():
  me.text(text="Select")
  me.select(
    label="Select",
    options=[
      me.SelectOption(label="label 1", value="value1"),
      me.SelectOption(label="label 2", value="value2"),
      me.SelectOption(label="label 3", value="value3"),
    ],
    on_selection_change=on_selection_change,
    multiple=True,
    style=me.Style(width=500),
  )
  s = me.state(State)
  me.text(text="Selected values: " + ", ".join(s.selected_values))
</page>

<page url=''>
import mesop.components.icon.icon_pb2 as icon_pb
from mesop.component_helpers import (
  Style,
  insert_component,
  register_native_component,
)


@register_native_component
def icon(
  icon: str | None = None,
  *,
  key: str | None = None,
  style: Style | None = None,
):
  """Creates a Icon component.

  Args:
    key: The component [key](../components/index.md#component-key).
    icon: Name of the [Material Symbols icon](https://fonts.google.com/icons).
    style: Inline styles
  """
  insert_component(
    key=key,
    type_name="icon",
    proto=icon_pb.IconType(
      icon=icon,
    ),
    style=style,
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/components/icon/e2e/icon_app")
def app():
  me.text(text="Hello, world!")
  me.icon(icon="home", style=me.Style(color="orange"))
</page>

<page url=''>
from . import icon_app as icon_app
</page>

<page url=''>
from dataclasses import dataclass
from typing import Any, Callable, Literal

import mesop.components.slide_toggle.slide_toggle_pb2 as slide_toggle_pb
from mesop.component_helpers import (
  component,
  insert_composite_component,
  register_event_handler,
  register_event_mapper,
  register_native_component,
)
from mesop.components.text.text import text
from mesop.events import MesopEvent


@dataclass(kw_only=True)
class SlideToggleChangeEvent(MesopEvent):
  """Event triggered when the slide toggle state changes.

  Attributes:
      key (str): Key of the component that emitted this event.
  """

  key: str


register_event_mapper(
  SlideToggleChangeEvent,
  lambda event, key: SlideToggleChangeEvent(
    key=key.key,
  ),
)


@component()
def slide_toggle(
  label: str | None = None,
  *,
  key: str | None = None,
  label_position: Literal["before", "after"] = "after",
  required: bool = False,
  color: Literal["primary", "accent", "warn"] | None = None,
  disabled: bool = False,
  disable_ripple: bool = False,
  tab_index: int = 0,
  checked: bool = False,
  hide_icon: bool = False,
  on_change: Callable[[SlideToggleChangeEvent], Any] | None = None,
):
  """Creates a simple Slide toggle component with a text label.

  Args:
    label: Text label for slide toggle
    on_change: An event will be dispatched each time the slide-toggle changes its value.
    label_position: Whether the label should appear after or before the slide-toggle. Defaults to 'after'.
    required: Whether the slide-toggle is required.
    color: Palette color of slide toggle.
    disabled: Whether the slide toggle is disabled.
    disable_ripple: Whether the slide toggle has a ripple.
    tab_index: Tabindex of slide toggle.
    checked: Whether the slide-toggle element is checked or not.
    hide_icon: Whether to hide the icon inside of the slide toggle.
    key: The component [key](../components/index.md#component-key).
  """
  with content_slide_toggle(
    key=key,
    label_position=label_position,
    required=required,
    color=color,
    disabled=disabled,
    disable_ripple=disable_ripple,
    tab_index=tab_index,
    checked=checked,
    hide_icon=hide_icon,
    on_change=on_change,
  ):
    text(label)


@register_native_component
def content_slide_toggle(
  *,
  key: str | None = None,
  label_position: Literal["before", "after"] = "after",
  required: bool = False,
  color: Literal["primary", "accent", "warn"] | None = None,
  disabled: bool = False,
  disable_ripple: bool = False,
  tab_index: int = 0,
  checked: bool = False,
  hide_icon: bool = False,
  on_change: Callable[[SlideToggleChangeEvent], Any] | None = None,
):
  """Creates a Slide toggle component which is a composite component. Typically, you would use a text or icon component as a child.

  Intended for advanced use cases.


  Args:
    on_change: An event will be dispatched each time the slide-toggle changes its value.
    label_position: Whether the label should appear after or before the slide-toggle. Defaults to 'after'.
    required: Whether the slide-toggle is required.
    color: Palette color of slide toggle.
    disabled: Whether the slide toggle is disabled.
    disable_ripple: Whether the slide toggle has a ripple.
    tab_index: Tabindex of slide toggle.
    checked: Whether the slide-toggle element is checked or not.
    hide_icon: Whether to hide the icon inside of the slide toggle.
    key: The component [key](../components/index.md#component-key).
  """
  return insert_composite_component(
    key=key,
    type_name="content_slide_toggle",
    proto=slide_toggle_pb.SlideToggleType(
      label_position=label_position,
      required=required,
      color=color,
      disabled=disabled,
      disable_ripple=disable_ripple,
      tab_index=tab_index,
      checked=checked,
      hide_icon=hide_icon,
      on_slide_toggle_change_event_handler_id=register_event_handler(
        on_change, event=SlideToggleChangeEvent
      )
      if on_change
      else "",
    ),
  )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  toggled: bool = False


def on_change(event: me.SlideToggleChangeEvent):
  s = me.state(State)
  s.toggled = not s.toggled


@me.page(path="/components/slide_toggle/e2e/slide_toggle_app")
def app():
  me.slide_toggle(label="hi", on_change=on_change)
  with me.content_slide_toggle(on_change=on_change):
    me.text("content_slide_toggle")
  s = me.state(State)
  me.text(text=f"Toggled: {s.toggled}")
</page>

<page url=''>
from . import slide_toggle_app as slide_toggle_app
</page>

<page url=''>
from typing import Literal

import mesop.components.badge.badge_pb2 as badge_pb
from mesop.component_helpers import (
  insert_composite_component,
  register_native_component,
)


@register_native_component
def badge(
  *,
  color: Literal["primary", "accent", "warn"] = "primary",
  overlap: bool = False,
  disabled: bool = False,
  position: Literal[
    "above after",
    "above before",
    "below before",
    "below after",
    "before",
    "after",
    "above",
    "below",
  ] = "above after",
  content: str = "",
  description: str = "",
  size: Literal["small", "medium", "large"] = "small",
  hidden: bool = False,
  key: str | None = None,
):
  """Creates a Badge component.
  Badge is a composite component.

  Args:
    color: The color of the badge. Can be `primary`, `accent`, or `warn`.
    overlap: Whether the badge should overlap its contents or not
    disabled: Whether the badge is disabled.
    position: Position the badge should reside. Accepts any combination of 'above'|'below' and 'before'|'after'
    content: The content for the badge
    description: Message used to describe the decorated element via aria-describedby
    size: Size of the badge. Can be 'small', 'medium', or 'large'.
    hidden: Whether the badge is hidden.
    key: The component [key](../components/index.md#component-key).
  """
  return insert_composite_component(
    key=key,
    type_name="badge",
    proto=badge_pb.BadgeType(
      color=color,
      overlap=overlap,
      disabled=disabled,
      position=position,
      content=content,
      description=description,
      size=size,
      hidden=hidden,
    ),
  )
</page>

<page url=''>
from . import badge_app as badge_app
</page>

<page url=''>
import mesop as me


@me.page(path="/components/badge/e2e/badge_app")
def app():
  with me.box(
    style=me.Style(
      display="block",
      padding=me.Padding(top=16, right=16, bottom=16, left=16),
      height=50,
      width=30,
      background="pink",
    )
  ):
    with me.badge(content="1"):
      me.text(text="some badge")
</page>

<page url=''>
from dataclasses import dataclass
from typing import Literal

import mesop.protos.ui_pb2 as pb

ContentAlignmentValues = Literal[
  "center",
  "start",
  "end",
  "flex",
  "flex",
  "left",
  "right",
  "space-between",
  "space-around",
  "space-evenly",
  "stretch",
]
ItemAlignmentValues = Literal[
  "normal",
  "stretch",
  "center",
  "start",
  "end",
  "flex-start",
  "flex-end",
  "self-start",
  "self-end",
  "baseline",
  "first baseline",
  "last baseline",
  "safe center",
  "unsafe center",
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset",
]
ItemJustifyValues = Literal[
  "normal",
  "stretch",
  "center",
  "start",
  "end",
  "flex-start",
  "flex-end",
  "self-start",
  "self-end",
  "left",
  "right",
  "baseline",
  "first baseline",
  "last baseline",
  "safe center",
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset",
]
OverflowValues = Literal["visible", "hidden", "clip", "scroll", "auto"]
OverflowWrapValues = Literal["normal", "break-word", "anywhere"]


@dataclass(kw_only=True)
class BorderSide:
  """
  Represents the style of a single side of a border in a UI component.

  Attributes:
      width: The width of the border. Can be specified as an integer value representing pixels,
                                a string with a unit (e.g., '2em'), or None for no width.
      color: The color of the border, represented as a string. This can be any valid CSS color value,
                          or None for no color.
      style: The style of the border. See https://developer.mozilla.org/en-US/docs/Web/CSS/border-style
  """

  width: int | str | None = None
  color: str | None = None
  style: (
    Literal[
      "none",
      "solid",
      "dashed",
      "dotted",
      "double",
      "groove",
      "ridge",
      "inset",
      "outset",
      "hidden",
    ]
    | None
  ) = None


@dataclass(kw_only=True)
class Border:
  """
  Defines the border styles for each side of a UI component.

  Attributes:
      top: Style for the top border.
      right: Style for the right border.
      bottom: Style for the bottom border.
      left: Style for the left border.
  """

  top: BorderSide | None = None
  right: BorderSide | None = None
  bottom: BorderSide | None = None
  left: BorderSide | None = None

  @staticmethod
  def all(value: BorderSide) -> "Border":
    """
    Creates a Border instance with all sides having the same style.

    Args:
        value: The style to apply to all sides of the border.

    Returns:
        Border: A new Border instance with the specified style applied to all sides.
    """
    return Border(top=value, right=value, bottom=value, left=value)

  @staticmethod
  def symmetric(
    *, vertical: BorderSide | None = None, horizontal: BorderSide | None = None
  ) -> "Border":
    """
    Creates a Border instance with symmetric styles for vertical and horizontal sides.

    Args:
        vertical: The style to apply to the top and bottom sides of the border.
        horizontal: The style to apply to the right and left sides of the border.

    Returns:
        Border: A new Border instance with the specified styles applied symmetrically.
    """
    return Border(
      top=vertical, right=horizontal, bottom=vertical, left=horizontal
    )


@dataclass(kw_only=True)
class _EdgeInsets:
  top: int | str | None = None
  right: int | str | None = None
  bottom: int | str | None = None
  left: int | str | None = None


@dataclass(kw_only=True)
class Margin(_EdgeInsets):
  """
  Defines the margin space around a UI component.

  Attributes:
      top: Top margin (note: `2` is the same as `2px`)
      right: Right margin
      bottom: Bottom margin
      left: Left margin
  """

  top: int | str | None = None
  right: int | str | None = None
  bottom: int | str | None = None
  left: int | str | None = None

  @staticmethod
  def all(value: int | str) -> "Margin":
    """
    Creates a Margin instance with the same value for all sides.

    Args:
        value: The value to apply to all sides of the margin. Can be an integer (pixel value) or a string.

    Returns:
        Margin: A new Margin instance with the specified value applied to all sides.
    """
    return Margin(top=value, right=value, bottom=value, left=value)

  @staticmethod
  def symmetric(
    *, vertical: int | str | None = None, horizontal: int | str | None = None
  ) -> "Margin":
    """
    Creates a Margin instance with symmetric values for vertical and horizontal sides.

    Args:
        vertical: The value to apply to the top and bottom sides of the margin. Can be an integer (pixel value) or a string.
        horizontal: The value to apply to the right and left sides of the margin. Can be an integer (pixel value) or a string.

    Returns:
        Margin: A new Margin instance with the specified values applied to the vertical and horizontal sides.
    """
    return Margin(
      top=vertical, right=horizontal, bottom=vertical, left=horizontal
    )


@dataclass(kw_only=True)
class Padding(_EdgeInsets):
  """
  Defines the padding space around a UI component.

  Attributes:
      top: Top padding (note: `2` is the same as `2px`)
      right: Right padding
      bottom: Bottom padding
      left: Left padding
  """

  top: int | str | None = None
  right: int | str | None = None
  bottom: int | str | None = None
  left: int | str | None = None

  @staticmethod
  def all(value: int | str) -> "Padding":
    """
    Creates a Padding instance with the same value for all sides.

    Args:
        value: The value to apply to all sides of the padding. Can be an integer (pixel value) or a string.

    Returns:
        Padding: A new Padding instance with the specified value applied to all sides.
    """
    return Padding(top=value, right=value, bottom=value, left=value)

  @staticmethod
  def symmetric(
    *, vertical: int | str | None = None, horizontal: int | str | None = None
  ) -> "Padding":
    """
    Creates a Padding instance with symmetric values for vertical and horizontal sides.

    Args:
        vertical: The value to apply to the top and bottom sides of the padding. Can be an integer (pixel value) or a string.
        horizontal: The value to apply to the right and left sides of the padding. Can be an integer (pixel value) or a string.

    Returns:
        Padding: A new Padding instance with the specified values applied to the vertical and horizontal sides.
    """
    return Padding(
      top=vertical, right=horizontal, bottom=vertical, left=horizontal
    )


@dataclass(kw_only=True)
class Style:
  """
  Represents the style configuration for a UI component.

  Attributes:
      align_content: Aligns the flexible container's items on the cross-axis. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/align-content).
      align_items: Specifies the default alignment for items inside a flexible container. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/align-items).
      align_self: Overrides a grid or flex item's align-items value. In Grid, it aligns the item inside the grid area. In Flexbox, it aligns the item on the cross axis. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/align-self).
      aspect_ratio: Specifies the desired width-to-height ratio of a component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio).
      background: Sets the background color or image of the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/background).
      border: Defines the border properties for each side of the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/border).
      border_radius: Defines the border radius. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius).
      bottom: Helps set vertical position of a positioned element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/bottom).
      box_shadow: Defines the box shadow. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow).
      box_sizing: Defines the box sizing. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing).
      color: Sets the color of the text inside the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/color).
      column_gap: Sets the gap between columns. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap).
      columns: Specifies the number of columns in a multi-column element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/columns).
      cursor: Sets the mouse cursor. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor).
      display: Defines the display type of the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/display).
      flex_basis: Specifies the initial length of a flexible item. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).
      flex_direction: Establishes the main-axis, thus defining the direction flex items are placed in the flex container. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction).
      flex_grow: Defines the ability for a flex item to grow if necessary. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-grow).
      flex_shrink: Defines the ability for a flex item to shrink if necessary. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink).
      flex_wrap: Allows flex items to wrap onto multiple lines. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap).
      font_family: Specifies the font family. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family).
      font_size: Sets the size of the font. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size).
      font_style: Specifies the font style for text. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style).
      font_weight: Sets the weight (or boldness) of the font. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight).
      gap: Sets the gap. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/gap).
      grid_area: Sets the grid area. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-area).
      grid_auto_columns: CSS property specifies the size of an implicitly-created grid column track or pattern of tracks. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-columns).
      grid_auto_flow: CSS property controls how the auto-placement algorithm works, specifying exactly how auto-placed items get flowed into the grid. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).
      grid_auto_rows: CSS property specifies the size of an implicitly-created grid row track or pattern of tracks. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-rows).
      grid_column: CSS shorthand property specifies a grid item's size and location within a grid column. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column).
      grid_column_start: Sets the grid column start. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start).
      grid_column_end: Sets the grid column end. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-end).
      grid_row: CSS shorthand property specifies a grid item's size and location within a grid row. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row).
      grid_row_start: Sets the grid row start. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-start).
      grid_row_end: Sets the grid row end. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-end).
      grid_template_areas: Sets the grid template areas; each element is a row. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-areas).
      grid_template_columns: Sets the grid template columns. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns).
      grid_template_rows: Sets the grid template rows. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-rows).
      height: Sets the height of the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/height).
      justify_content: Aligns the flexible container's items on the main-axis. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content).
      justify_items: Defines the default justify-self for all items of the box, giving them all a default way of justifying each box along the appropriate axis. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items).
      justify_self: Sets the way a box is justified inside its alignment container along the appropriate axis. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self).
      left: Helps set horizontal position of a positioned element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/left).
      letter_spacing: Increases or decreases the space between characters in text. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing).
      line height: Set the line height (relative to the font size). See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height).
      margin: Sets the margin space required on each side of an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/margin).
      max_height: Sets the maximum height of an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/max-height).
      max_width: Sets the maximum width of an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/max-width).
      min_height: Sets the minimum height of an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/min-height).
      min_width: Sets the minimum width of an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/min-width).
      opacity: Sets the opacity property. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/opacity).
      outline: Sets the outline property. Note: `input` component has default browser stylings. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/outline).
      overflow_wrap: Specifies how long text can be broken up by new lines to prevent overflowing. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap).
      overflow_x: Specifies the handling of overflow in the horizontal direction. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x).
      overflow_y: Specifies the handling of overflow in the vertical direction. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y).
      padding: Sets the padding space required on each side of an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/padding).
      position: Specifies the type of positioning method used for an element (static, relative, absolute, fixed, or sticky). See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/position).
      right: Helps set horizontal position of a positioned element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/right).
      rotate: Allows you to specify rotation transforms individually and independently of the transform property. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/rotate).
      row_gap: Sets the gap between rows. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap).
      text_align: Specifies the horizontal alignment of text in an element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align).
      text_decoration: Specifies the decoration added to text. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration).
      text_overflow: Specifies how overflowed content that is not displayed should be signaled to the user. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow).
      top: Helps set vertical position of a positioned element. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/top).
      transform: Lets you rotate, scale, skew, or translate an element. It modifies the coordinate space of the CSS visual formatting model. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/transform).
      visibility: Sets the visibility property. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/visibility).
      white_space: Specifies how white space inside an element is handled. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space).
      width: Sets the width of the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/width).
      z-index: Sets the z-index of the component. See [MDN doc](https://developer.mozilla.org/en-US/docs/Web/CSS/z-index).
  """

  # For literal properties, make the most commonly used option the first literal
  # element, as it will be used as the default value by the editor when creating that property.

  align_content: ContentAlignmentValues | None = None
  align_items: ItemAlignmentValues | None = None
  align_self: ItemAlignmentValues | None = None
  aspect_ratio: str | None = None
  background: str | None = None
  border: Border | None = None
  border_radius: int | str | None = None
  bottom: int | str | None = None
  box_shadow: str | None = None
  box_sizing: str | None = None
  color: str | None = None
  column_gap: int | str | None = None
  columns: int | str | None = None
  cursor: str | None = None
  display: (
    Literal[
      # precomposed values
      "block",
      "inline",
      "inline-block",
      "flex",
      "inline-flex",
      "grid",
      "inline-grid",
      # box generation
      "none",
      "contents",
    ]
    | None
  ) = None
  flex_basis: str | None = None
  flex_direction: (
    Literal[
      "row",
      "row-reverse",
      "column",
      "column-reverse",
    ]
    | None
  ) = None
  flex_grow: int | None = None
  flex_shrink: int | None = None
  flex_wrap: Literal["nowrap", "wrap", "wrap-reverse"] | None = None
  font_family: str | None = None
  font_size: int | str | None = None
  font_style: Literal["italic", "normal"] | None = None
  font_weight: (
    Literal[
      "bold",
      "normal",
      100,
      200,
      300,
      400,
      500,
      600,
      700,
      800,
      900,
    ]
    | None
  ) = None
  gap: int | str | None = None
  grid_area: str | None = None
  grid_auto_columns: str | None = None
  grid_auto_flow: str | None = None
  grid_auto_rows: str | None = None
  grid_column: str | None = None
  grid_column_start: int | str | None = None
  grid_column_end: int | str | None = None
  grid_row: str | None = None
  grid_row_start: int | str | None = None
  grid_row_end: int | str | None = None
  grid_template_areas: list[str] | None = None
  grid_template_columns: str | None = None
  grid_template_rows: str | None = None
  height: int | str | None = None
  justify_content: ContentAlignmentValues | None = None
  justify_items: ItemJustifyValues | None = None
  justify_self: ItemJustifyValues | None = None
  left: int | str | None = None
  letter_spacing: int | str | None = None
  line_height: str | None = None
  margin: Margin | None = None
  max_height: int | str | None = None
  max_width: int | str | None = None
  min_height: int | str | None = None
  min_width: int | str | None = None
  opacity: float | str | None = None
  outline: str | None = None
  overflow_wrap: OverflowWrapValues | None = None
  overflow_x: OverflowValues | None = None
  overflow_y: OverflowValues | None = None
  padding: Padding | None = None
  position: (
    Literal[
      "static",
      "relative",
      "absolute",
      "fixed",
      "sticky",
    ]
    | None
  ) = None
  right: int | str | None = None
  rotate: str | None = None
  row_gap: int | str | None = None
  text_align: (
    Literal[
      "start",
      "end",
      "left",
      "right",
      "center",
    ]
    | None
  ) = None
  text_decoration: Literal["underline", "none"] | None = None
  text_overflow: Literal["ellipsis", "clip"] | None = None
  top: int | str | None = None
  transform: str | None = None
  visibility: (
    Literal[
      "visible",
      "hidden",
      "collapse",
      "inherit",
      "initial",
      "revert",
      "revert-layer",
      "unset",
    ]
    | None
  ) = None
  white_space: (
    Literal[
      "normal",
      "nowrap",
      "pre",
      "pre-wrap",
      "pre-line",
      "break-spaces",
    ]
    | None
  ) = None
  width: int | str | None = None
  z_index: int | None = None


def to_style_proto(s: Style) -> pb.Style:
  return pb.Style(
    align_content=s.align_content,
    align_items=s.align_items,
    align_self=s.align_self,
    aspect_ratio=s.aspect_ratio,
    background=s.background,
    border=_map_border(s.border),
    border_radius=_px_str(s.border_radius),
    bottom=_px_str(s.bottom),
    box_shadow=s.box_shadow,
    box_sizing=s.box_sizing,
    color=s.color,
    column_gap=_px_str(s.column_gap),
    columns=_int_str(s.columns),
    cursor=s.cursor,
    display=s.display,
    flex_basis=s.flex_basis,
    flex_direction=s.flex_direction,
    flex_grow=s.flex_grow,
    flex_shrink=_int_str(s.flex_shrink),
    flex_wrap=s.flex_wrap,
    font_family=s.font_family,
    font_size=_px_str(s.font_size),
    font_style=s.font_style,
    font_weight=_map_font_weight(s.font_weight),
    gap=_px_str(s.gap),
    grid_area=s.grid_area,
    grid_auto_columns=s.grid_auto_columns,
    grid_auto_flow=s.grid_auto_flow,
    grid_auto_rows=s.grid_auto_rows,
    grid_column=s.grid_column,
    grid_column_start=_int_str(s.grid_column_start),
    grid_column_end=_int_str(s.grid_column_end),
    grid_row=s.grid_row,
    grid_row_start=_int_str(s.grid_row_start),
    grid_row_end=_int_str(s.grid_row_end),
    grid_template_areas=s.grid_template_areas,
    grid_template_columns=s.grid_template_columns,
    grid_template_rows=s.grid_template_rows,
    height=_px_str(s.height),
    justify_content=s.justify_content,
    justify_items=s.justify_items,
    justify_self=s.justify_self,
    left=_px_str(s.left),
    letter_spacing=_px_str(s.letter_spacing),
    line_height=str(s.line_height),
    margin=_map_edge_insets(s.margin),
    max_height=_px_str(s.max_height),
    max_width=_px_str(s.max_width),
    min_height=_px_str(s.min_height),
    min_width=_px_str(s.min_width),
    opacity=_float_str(s.opacity),
    outline=s.outline,
    overflow_wrap=s.overflow_wrap,
    overflow_x=s.overflow_x,
    overflow_y=s.overflow_y,
    padding=_map_edge_insets(s.padding),
    position=s.position,
    right=_px_str(s.right),
    rotate=s.rotate,
    row_gap=_px_str(s.row_gap),
    text_align=s.text_align,
    text_decoration=s.text_decoration,
    text_overflow=s.text_overflow,
    top=_px_str(s.top),
    transform=s.transform,
    visibility=s.visibility,
    white_space=s.white_space,
    width=_px_str(s.width),
    z_index=s.z_index,
  )


def _map_font_weight(fw: int | str | None) -> str:
  if fw is None:
    return ""
  return str(fw)


def _map_edge_insets(e: _EdgeInsets | None) -> pb.EdgeInsets | None:
  if e is None:
    return None
  return pb.EdgeInsets(
    top=_px_str(e.top),
    bottom=_px_str(e.bottom),
    left=_px_str(e.left),
    right=_px_str(e.right),
  )


def _map_border(b: Border | None) -> pb.Border | None:
  if b is None:
    return None
  return pb.Border(
    top=_map_border_side(b.top),
    bottom=_map_border_side(b.bottom),
    left=_map_border_side(b.left),
    right=_map_border_side(b.right),
  )


def _map_border_side(bs: BorderSide | None) -> pb.BorderSide | None:
  if bs is None:
    return None
  return pb.BorderSide(width=_px_str(bs.width), color=bs.color, style=bs.style)


def _px_str(int_or_str: int | str | None) -> str | None:
  if isinstance(int_or_str, int):
    return str(int_or_str) + "px"
  return int_or_str


def _int_str(int_or_str: int | str | None) -> str | None:
  if isinstance(int_or_str, int):
    return str(int_or_str)
  return int_or_str


def _float_str(float_or_str: float | str | None) -> str | None:
  # Int is included to fix type check warning:
  # Expression of type "int | str | None" cannot be assigned to return type "str | None"
  if isinstance(float_or_str, (float, int)):
    return str(float_or_str)
  return float_or_str
</page>

These are example applications you can build with Mesop:<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/icon",
)
def app():
  me.text("home icon")
  me.icon(icon="home")
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/link",
)
def link():
  me.link(text="Open in same tab", url="https://google.github.io/mesop/")
  me.link(
    text="Open in new tab",
    open_in_new_tab=True,
    url="https://google.github.io/mesop/",
  )
  me.link(
    text="Styled link",
    url="https://google.github.io/mesop/",
    style=me.Style(color="black", text_decoration="none"),
  )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  sidenav_open: bool


def on_click(e: me.ClickEvent):
  s = me.state(State)
  s.sidenav_open = not s.sidenav_open


SIDENAV_WIDTH = 200


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/sidenav",
)
def app():
  state = me.state(State)
  with me.sidenav(
    opened=state.sidenav_open, style=me.Style(width=SIDENAV_WIDTH)
  ):
    me.text("Inside sidenav")

  with me.box(
    style=me.Style(
      margin=me.Margin(left=SIDENAV_WIDTH if state.sidenav_open else 0),
    ),
  ):
    with me.content_button(on_click=on_click):
      me.icon("menu")
    me.markdown("Main content")
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  input: str = ""


def on_blur(e: me.InputBlurEvent):
  state = me.state(State)
  state.input = e.value


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/textarea",
)
def app():
  s = me.state(State)
  me.textarea(label="Basic input", on_blur=on_blur)
  me.text(text=s.input)
</page>

<page url=''>
"""Simple snackbar component that is similar to Angular Component Snackbar."""

import time
from typing import Callable, Literal

import mesop as me


@me.stateclass
class State:
  is_visible: bool = False
  duration: int = 0
  horizontal_position: str = "center"
  vertical_position: str = "end"


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/snackbar",
)
def app():
  me.set_theme_mode("dark")
  state = me.state(State)

  snackbar(
    label="Cannonball!!!",
    action_label="Splash",
    on_click_action=on_click_snackbar_close,
    is_visible=state.is_visible,
    horizontal_position=state.horizontal_position,  # type: ignore
    vertical_position=state.vertical_position,  # type: ignore
  )

  with me.box(style=me.Style(padding=me.Padding.all(30))):
    with me.box():
      me.select(
        label="Horizontal Position",
        on_selection_change=on_horizontal_position_change,
        options=[
          me.SelectOption(label="start", value="start"),
          me.SelectOption(label="center", value="center"),
          me.SelectOption(label="end", value="end"),
        ],
      )

    with me.box():
      me.select(
        label="Vertical Position",
        on_selection_change=on_vertical_position_change,
        options=[
          me.SelectOption(label="start", value="start"),
          me.SelectOption(label="center", value="center"),
          me.SelectOption(label="end", value="end"),
        ],
      )

    with me.box():
      me.select(
        label="Duration",
        on_selection_change=on_duration_change,
        options=[
          me.SelectOption(label="None", value="0"),
          me.SelectOption(label="3 seconds", value="3"),
        ],
      )

    me.button(
      "Trigger snackbar",
      type="flat",
      color="primary",
      on_click=on_click_snackbar_open,
    )


def on_horizontal_position_change(e: me.SelectSelectionChangeEvent):
  state = me.state(State)
  state.horizontal_position = e.value


def on_vertical_position_change(e: me.SelectSelectionChangeEvent):
  state = me.state(State)
  state.vertical_position = e.value


def on_duration_change(e: me.SelectSelectionChangeEvent):
  state = me.state(State)
  state.duration = int(e.value)


def on_click_snackbar_close(e: me.ClickEvent):
  state = me.state(State)
  state.is_visible = False


def on_click_snackbar_open(e: me.ClickEvent):
  state = me.state(State)
  state.is_visible = True

  # Use yield to create a timed snackbar message.
  if state.duration:
    yield
    time.sleep(state.duration)
    state.is_visible = False
    yield
  else:
    yield


@me.component
def snackbar(
  *,
  is_visible: bool,
  label: str,
  action_label: str | None = None,
  on_click_action: Callable | None = None,
  horizontal_position: Literal["start", "center", "end"] = "center",
  vertical_position: Literal["start", "center", "end"] = "end",
):
  """Creates a snackbar.

  By default the snackbar is rendered at bottom center.

  The on_click_action should typically close the snackbar as part of its actions. If no
  click event is included, you'll need to manually hide the snackbar.

  Note that there is one issue with this snackbar example. No actions are possible until
  the snackbar is dismissed or closed. This is due to the fixed box that gets created when
  the snackbar is visible.

  Args:
    is_visible: Whether the snackbar is currently visible or not.
    label: Message for the snackbar
    action_label: Optional message for the action of the snackbar
    on_click_action: Optional click event when action is triggered.
    horizontal_position: Horizontal position of the snackbar
    vertical_position: Vertical position of the snackbar
  """
  with me.box(
    style=me.Style(
      display="block" if is_visible else "none",
      height="100%",
      overflow_x="auto",
      overflow_y="auto",
      position="fixed",
      width="100%",
      z_index=1000,
    )
  ):
    with me.box(
      style=me.Style(
        align_items=vertical_position,
        height="100%",
        display="flex",
        justify_content=horizontal_position,
      )
    ):
      with me.box(
        style=me.Style(
          align_items="center",
          background=me.theme_var("on-surface-variant"),
          border_radius=5,
          box_shadow=(
            "0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"
          ),
          display="flex",
          font_size=14,
          justify_content="space-between",
          margin=me.Margin.all(10),
          padding=me.Padding(top=5, bottom=5, right=5, left=15)
          if action_label
          else me.Padding.all(15),
          width=300,
        )
      ):
        me.text(
          label, style=me.Style(color=me.theme_var("surface-container-lowest"))
        )
        if action_label:
          me.button(
            action_label,
            on_click=on_click_action,
            style=me.Style(color=me.theme_var("primary-container")),
          )
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/box",
)
def app():
  with me.box(style=me.Style(background="red", padding=me.Padding.all(16))):
    with me.box(
      style=me.Style(
        background="green",
        height=50,
        margin=me.Margin.symmetric(vertical=24, horizontal=12),
        border=me.Border.symmetric(
          horizontal=me.BorderSide(width=2, color="pink", style="solid"),
          vertical=me.BorderSide(width=2, color="orange", style="solid"),
        ),
      )
    ):
      me.text(text="hi1")
      me.text(text="hi2")

    with me.box(
      style=me.Style(
        background="blue",
        height=50,
        margin=me.Margin.all(16),
        border=me.Border.all(
          me.BorderSide(width=2, color="yellow", style="dotted")
        ),
        border_radius=10,
      )
    ):
      me.text(text="Example with all sides bordered")

    with me.box(
      style=me.Style(
        background="purple",
        height=50,
        margin=me.Margin.symmetric(vertical=24, horizontal=12),
        border=me.Border.symmetric(
          vertical=me.BorderSide(width=4, color="white", style="double")
        ),
      )
    ):
      me.text(text="Example with top and bottom borders")

    with me.box(
      style=me.Style(
        background="cyan",
        height=50,
        margin=me.Margin.symmetric(vertical=24, horizontal=12),
        border=me.Border.symmetric(
          horizontal=me.BorderSide(width=2, color="black", style="groove")
        ),
      )
    ):
      me.text(text="Example with left and right borders")
</page>

<page url=''>
from matplotlib.figure import Figure

import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/plot",
)
def app():
  # Create matplotlib figure without using pyplot:
  fig = Figure()
  ax = fig.subplots()  # type: ignore
  ax.plot([1, 2])  # type: ignore

  me.text("Example using matplotlib:")
  me.plot(fig, style=me.Style(width="100%"))
</page>

<page url=''>
import mesop as me
import mesop.labs as mel


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/text_to_image",
  title="Text to Image Example",
)
def app():
  mel.text_to_image(
    generate_image,
    title="Text to Image Example",
  )


def generate_image(prompt: str):
  return "https://www.google.com/logos/doodles/2024/earth-day-2024-6753651837110453-2xa.gif"
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/embed",
)
def app():
  src = "https://google.github.io/mesop/"
  me.text("Embedding: " + src)
  me.embed(
    src=src,
    style=me.Style(width="100%", height="100%"),
  )
</page>

<page url=''>
"""Simple dialog that looks similar to Angular Component Dialog."""

import mesop as me


@me.stateclass
class State:
  is_open: bool = False


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/dialog",
)
def app():
  state = me.state(State)

  with dialog(state.is_open):
    me.text("Delete File", type="headline-5")
    with me.box():
      me.text(text="Would you like to delete cat.jpeg?")
    with dialog_actions():
      me.button("No", on_click=on_click_close_dialog)
      me.button("Yes", on_click=on_click_close_dialog)

  with me.box(style=me.Style(padding=me.Padding.all(30))):
    me.button(
      "Open Dialog", type="flat", color="primary", on_click=on_click_dialog_open
    )


def on_click_close_dialog(e: me.ClickEvent):
  state = me.state(State)
  state.is_open = False


def on_click_dialog_open(e: me.ClickEvent):
  state = me.state(State)
  state.is_open = True


@me.content_component
def dialog(is_open: bool):
  """Renders a dialog component.

  The design of the dialog borrows from the Angular component dialog. So basically
  rounded corners and some box shadow.

  One current drawback is that it's not possible to close the dialog
  by clicking on the overlay background. This is due to
  https://github.com/google/mesop/issues/268.

  Args:
    is_open: Whether the dialog is visible or not.
  """
  with me.box(
    style=me.Style(
      background="rgba(0, 0, 0, 0.4)"
      if me.theme_brightness() == "light"
      else "rgba(255, 255, 255, 0.4)",
      display="block" if is_open else "none",
      height="100%",
      overflow_x="auto",
      overflow_y="auto",
      position="fixed",
      width="100%",
      z_index=1000,
    )
  ):
    with me.box(
      style=me.Style(
        align_items="center",
        display="grid",
        height="100vh",
        justify_items="center",
      )
    ):
      with me.box(
        style=me.Style(
          background=me.theme_var("surface-container-lowest"),
          border_radius=20,
          box_sizing="content-box",
          box_shadow=(
            "0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"
          ),
          margin=me.Margin.symmetric(vertical="0", horizontal="auto"),
          padding=me.Padding.all(20),
        )
      ):
        me.slot()


@me.content_component
def dialog_actions():
  """Helper component for rendering action buttons so they are right aligned.

  This component is optional. If you want to position action buttons differently,
  you can just write your own Mesop markup.
  """
  with me.box(
    style=me.Style(
      display="flex", justify_content="end", gap=5, margin=me.Margin(top=20)
    )
  ):
    me.slot()
</page>

<page url=''>
import inspect

import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/code_demo",
)
def code_demo():
  me.text("Defaults to Python")
  me.code("a = 123")

  me.text("Can set to other languages")
  me.code("<div class='a'>foo</div>", language="html")

  me.text("Bigger code block")
  me.code(inspect.getsource(me))
</page>

<page url=''>
import mesop as me


@me.stateclass
class FeedbackState:
  feedback: str = ""
  reason: str = ""
  ask_reason: bool = False


def on_feedback(isup: bool):
  state = me.state(FeedbackState)
  state.feedback = "Thumbs up!" if isup else "Thumbs down!"
  state.ask_reason = not isup


def on_reason_input(e: me.InputEvent):
  state = me.state(FeedbackState)
  state.reason = e.value


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/feedback",
)
def feedback_page():
  state = me.state(FeedbackState)

  me.text("Provide your feedback:", type="headline-5")

  with me.box(style=me.Style(display="flex", flex_direction="row", gap=20)):
    me.button("👍", type="flat", on_click=lambda _: on_feedback(True))
    me.button("👎", type="flat", on_click=lambda _: on_feedback(False))

  if state.ask_reason:
    me.textarea(label="Tell us why", on_input=on_reason_input)

  if state.feedback:
    me.text(f"\n\nFeedback : {state.feedback}")
    if state.reason:
      me.text(f"Reason : {state.reason}")
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/progress_spinner",
)
def app():
  me.progress_spinner()
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/divider",
)
def app():
  me.text(text="before")
  me.divider()
  me.text(text="after")
</page>

<page url=''>
import random
import time
from typing import Callable

import mesop as me

_TEMPERATURE_MIN = 0.0
_TEMPERATURE_MAX = 2.0
_TOKEN_LIMIT_MIN = 1
_TOKEN_LIMIT_MAX = 8192


@me.stateclass
class State:
  title: str = "LLM Playground"
  # Prompt / Response
  input: str
  response: str
  # Tab open/close
  prompt_tab: bool = True
  response_tab: bool = True
  # Model configs
  selected_model: str = "gemini-1.5"
  selected_region: str = "us-east4"
  temperature: float = 1.0
  temperature_for_input: float = 1.0
  token_limit: int = _TOKEN_LIMIT_MAX
  token_limit_for_input: int = _TOKEN_LIMIT_MAX
  stop_sequence: str = ""
  stop_sequences: list[str]
  # Modal
  modal_open: bool = False
  # Workaround for clearing inputs
  clear_prompt_count: int = 0
  clear_sequence_count: int = 0


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/llm_playground",
  title="LLM Playground",
)
def page():
  state = me.state(State)

  # Modal
  with modal(modal_open=state.modal_open):
    me.text("Get code", type="headline-5")
    if "gemini" in state.selected_model:
      me.text(
        "Use the following code in your application to request a model response."
      )
      with me.box(style=_STYLE_CODE_BOX):
        me.markdown(
          _GEMINI_CODE_TEXT.format(
            content=state.input.replace('"', '\\"'),
            model=state.selected_model,
            region=state.selected_region,
            stop_sequences=make_stop_sequence_str(state.stop_sequences),
            token_limit=state.token_limit,
            temperature=state.temperature,
          )
        )
    else:
      me.text(
        "You can use the following code to start integrating your current prompt and settings into your application."
      )
      with me.box(style=_STYLE_CODE_BOX):
        me.markdown(
          _GPT_CODE_TEXT.format(
            content=state.input.replace('"', '\\"').replace("\n", "\\n"),
            model=state.selected_model,
            stop_sequences=make_stop_sequence_str(state.stop_sequences),
            token_limit=state.token_limit,
            temperature=state.temperature,
          )
        )
    me.button(label="Close", type="raised", on_click=on_click_modal)

  # Main content
  with me.box(style=_STYLE_CONTAINER):
    # Main Header
    with me.box(style=_STYLE_MAIN_HEADER):
      with me.box(style=_STYLE_TITLE_BOX):
        me.text(
          state.title,
          type="headline-6",
          style=me.Style(line_height="24px", margin=me.Margin(bottom=0)),
        )

    # Toolbar Header
    with me.box(style=_STYLE_CONFIG_HEADER):
      icon_button(
        icon="code", tooltip="Code", label="CODE", on_click=on_click_show_code
      )

    # Main Content
    with me.box(style=_STYLE_MAIN_COLUMN):
      # Prompt Tab
      with tab_box(header="Prompt", key="prompt_tab"):
        me.textarea(
          label="Write your prompt here, insert media and then click Submit",
          # Workaround: update key to clear input.
          key=f"prompt-{state.clear_prompt_count}",
          on_input=on_prompt_input,
          style=_STYLE_INPUT_WIDTH,
        )
        me.button(label="Submit", type="flat", on_click=on_click_submit)
        me.button(label="Clear", on_click=on_click_clear)

      # Response Tab
      with tab_box(header="Response", key="response_tab"):
        if state.response:
          me.markdown(state.response)
        else:
          me.markdown(
            "The model will generate a response after you click Submit."
          )

    # LLM Config
    with me.box(style=_STYLE_CONFIG_COLUMN):
      me.select(
        options=[
          me.SelectOption(label="Gemini 1.5", value="gemini-1.5"),
          me.SelectOption(label="Chat-GPT Turbo", value="gpt-3.5-turbo"),
        ],
        label="Model",
        style=_STYLE_INPUT_WIDTH,
        on_selection_change=on_model_select,
        value=state.selected_model,
      )

      if "gemini" in state.selected_model:
        me.select(
          options=[
            me.SelectOption(label="us-central1 (Iowa)", value="us-central1"),
            me.SelectOption(
              label="us-east4 (North Virginia)", value="us-east4"
            ),
          ],
          label="Region",
          style=_STYLE_INPUT_WIDTH,
          on_selection_change=on_region_select,
          value=state.selected_region,
        )

      me.text("Temperature", style=_STYLE_SLIDER_LABEL)
      with me.box(style=_STYLE_SLIDER_INPUT_BOX):
        with me.box(style=_STYLE_SLIDER_WRAP):
          me.slider(
            min=_TEMPERATURE_MIN,
            max=_TEMPERATURE_MAX,
            step=0.1,
            style=_STYLE_SLIDER,
            on_value_change=on_slider_temperature,
            value=state.temperature,
          )
        me.input(
          style=_STYLE_SLIDER_INPUT,
          value=str(state.temperature_for_input),
          on_input=on_input_temperature,
        )

      me.text("Output Token Limit", style=_STYLE_SLIDER_LABEL)
      with me.box(style=_STYLE_SLIDER_INPUT_BOX):
        with me.box(style=_STYLE_SLIDER_WRAP):
          me.slider(
            min=_TOKEN_LIMIT_MIN,
            max=_TOKEN_LIMIT_MAX,
            style=_STYLE_SLIDER,
            on_value_change=on_slider_token_limit,
            value=state.token_limit,
          )
        me.input(
          style=_STYLE_SLIDER_INPUT,
          value=str(state.token_limit_for_input),
          on_input=on_input_token_limit,
        )

      with me.box(style=_STYLE_STOP_SEQUENCE_BOX):
        with me.box(style=_STYLE_STOP_SEQUENCE_WRAP):
          me.input(
            label="Add stop sequence",
            style=_STYLE_INPUT_WIDTH,
            on_input=on_stop_sequence_input,
            # Workaround: update key to clear input.
            key=f"input-sequence-{state.clear_sequence_count}",
          )
        with me.content_button(
          style=me.Style(margin=me.Margin(left=10)),
          on_click=on_click_add_stop_sequence,
        ):
          with me.tooltip(message="Add stop Sequence"):
            me.icon(icon="add_circle")

      # Stop sequence "chips"
      for index, sequence in enumerate(state.stop_sequences):
        me.button(
          key=f"sequence-{index}",
          label=sequence,
          on_click=on_click_remove_stop_sequence,
          type="raised",
          style=_STYLE_STOP_SEQUENCE_CHIP,
        )


# HELPER COMPONENTS


@me.component
def icon_button(*, icon: str, label: str, tooltip: str, on_click: Callable):
  """Icon button with text and tooltip."""
  with me.content_button(on_click=on_click):
    with me.tooltip(message=tooltip):
      with me.box(style=me.Style(display="flex")):
        me.icon(icon=icon)
        me.text(
          label, style=me.Style(line_height="24px", margin=me.Margin(left=5))
        )


@me.content_component
def tab_box(*, header: str, key: str):
  """Collapsible tab box"""
  state = me.state(State)
  tab_open = getattr(state, key)
  with me.box(style=me.Style(width="100%", margin=me.Margin(bottom=20))):
    # Tab Header
    with me.box(
      key=key,
      on_click=on_click_tab_header,
      style=me.Style(padding=_DEFAULT_PADDING, border=_DEFAULT_BORDER),
    ):
      with me.box(style=me.Style(display="flex")):
        me.icon(
          icon="keyboard_arrow_down" if tab_open else "keyboard_arrow_right"
        )
        me.text(
          header,
          style=me.Style(
            line_height="24px", margin=me.Margin(left=5), font_weight="bold"
          ),
        )
    # Tab Content
    with me.box(
      style=me.Style(
        padding=_DEFAULT_PADDING,
        border=_DEFAULT_BORDER,
        display="block" if tab_open else "none",
      )
    ):
      me.slot()


@me.content_component
def modal(modal_open: bool):
  """Basic modal box."""
  with me.box(style=_make_modal_background_style(modal_open)):
    with me.box(style=_STYLE_MODAL_CONTAINER):
      with me.box(style=_STYLE_MODAL_CONTENT):
        me.slot()


# EVENT HANDLERS


def on_click_clear(e: me.ClickEvent):
  """Click event for clearing prompt text."""
  state = me.state(State)
  state.clear_prompt_count += 1
  state.input = ""
  state.response = ""


def on_prompt_input(e: me.InputEvent):
  """Capture prompt input."""
  state = me.state(State)
  state.input = e.value


def on_model_select(e: me.SelectSelectionChangeEvent):
  """Event to select model."""
  state = me.state(State)
  state.selected_model = e.value


def on_region_select(e: me.SelectSelectionChangeEvent):
  """Event to select GCP region (Gemini models only)."""
  state = me.state(State)
  state.selected_region = e.value


def on_slider_temperature(e: me.SliderValueChangeEvent):
  """Event to adjust temperature slider value."""
  state = me.state(State)
  state.temperature = float(e.value)
  state.temperature_for_input = state.temperature


def on_input_temperature(e: me.InputEvent):
  """Event to adjust temperature slider value by input."""
  state = me.state(State)
  try:
    temperature = float(e.value)
    if _TEMPERATURE_MIN <= temperature <= _TEMPERATURE_MAX:
      state.temperature = temperature
  except ValueError:
    pass


def on_slider_token_limit(e: me.SliderValueChangeEvent):
  """Event to adjust token limit slider value."""
  state = me.state(State)
  state.token_limit = int(e.value)
  state.token_limit_for_input = state.token_limit


def on_input_token_limit(e: me.InputEvent):
  """Event to adjust token limit slider value by input."""
  state = me.state(State)
  try:
    token_limit = int(e.value)
    if _TOKEN_LIMIT_MIN <= token_limit <= _TOKEN_LIMIT_MAX:
      state.token_limit = token_limit
  except ValueError:
    pass


def on_stop_sequence_input(e: me.InputEvent):
  """Capture stop sequence input."""
  state = me.state(State)
  state.stop_sequence = e.value


def on_click_add_stop_sequence(e: me.ClickEvent):
  """Save stop sequence. Will create "chip" for the sequence in the input."""
  state = me.state(State)
  if state.stop_sequence:
    state.stop_sequences.append(state.stop_sequence)
    state.clear_sequence_count += 1


def on_click_remove_stop_sequence(e: me.ClickEvent):
  """Click event that removes the stop sequence that was clicked."""
  state = me.state(State)
  index = int(e.key.replace("sequence-", ""))
  del state.stop_sequences[index]


def on_click_tab_header(e: me.ClickEvent):
  """Open and closes tab content."""
  state = me.state(State)
  setattr(state, e.key, not getattr(state, e.key))


def on_click_show_code(e: me.ClickEvent):
  """Opens modal to show generated code for the given model configuration."""
  state = me.state(State)
  state.modal_open = True


def on_click_modal(e: me.ClickEvent):
  """Allows modal to be closed."""
  state = me.state(State)
  if state.modal_open:
    state.modal_open = False


def on_click_submit(e: me.ClickEvent):
  """Submits prompt to test model configuration.

  This example returns canned text. A real implementation
  would call APIs against the given configuration.
  """
  state = me.state(State)
  for line in transform(state.input):
    state.response += line
    yield


def transform(input: str):
  """Transform function that returns canned responses."""
  for line in random.sample(LINES, random.randint(3, len(LINES) - 1)):
    time.sleep(0.3)
    yield line + " "


LINES = [
  "Mesop is a Python-based UI framework designed to simplify web UI development for engineers without frontend experience.",
  "It leverages the power of the Angular web framework and Angular Material components, allowing rapid construction of web demos and internal tools.",
  "With Mesop, developers can enjoy a fast build-edit-refresh loop thanks to its hot reload feature, making UI tweaks and component integration seamless.",
  "Deployment is straightforward, utilizing standard HTTP technologies.",
  "Mesop's component library aims for comprehensive Angular Material component coverage, enhancing UI flexibility and composability.",
  "It supports custom components for specific use cases, ensuring developers can extend its capabilities to fit their unique requirements.",
  "Mesop's roadmap includes expanding its component library and simplifying the onboarding processs.",
]


# HELPERS

_GEMINI_CODE_TEXT = """
```python
import base64
import vertexai
from vertexai.generative_models import GenerativeModel, Part, FinishReason
import vertexai.preview.generative_models as generative_models

def generate():
  vertexai.init(project="<YOUR-PROJECT-ID>", location="{region}")
  model = GenerativeModel("{model}")
  responses = model.generate_content(
      [\"\"\"{content}\"\"\"],
      generation_config=generation_config,
      safety_settings=safety_settings,
      stream=True,
  )

  for response in responses:
    print(response.text, end="")


generation_config = {{
    "max_output_tokens": {token_limit},
    "stop_sequences": [{stop_sequences}],
    "temperature": {temperature},
    "top_p": 0.95,
}}

safety_settings = {{
    generative_models.HarmCategory.HARM_CATEGORY_HATE_SPEECH: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    generative_models.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    generative_models.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    generative_models.HarmCategory.HARM_CATEGORY_HARASSMENT: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
}}

generate()
```
""".strip()

_GPT_CODE_TEXT = """
```python
from openai import OpenAI
client = OpenAI()

response = client.chat.completions.create(
  model="{model}",
  messages=[
    {{
      "role": "user",
      "content": "{content}"
    }}
  ],
  temperature={temperature},
  max_tokens={token_limit},
  top_p=1,
  frequency_penalty=0,
  presence_penalty=0,
  stop=[{stop_sequences}]
)
```
""".strip()


def make_stop_sequence_str(stop_sequences: list[str]) -> str:
  """Formats stop sequences for code output (list of strings)."""
  return ",".join(map(lambda s: f'"{s}"', stop_sequences))


# STYLES


def _make_modal_background_style(modal_open: bool) -> me.Style:
  """Makes style for modal background.

  Args:
    modal_open: Whether the modal is open.
  """
  return me.Style(
    display="block" if modal_open else "none",
    position="fixed",
    z_index=1000,
    width="100%",
    height="100%",
    overflow_x="auto",
    overflow_y="auto",
    background="rgba(0,0,0,0.4)",
  )


_DEFAULT_PADDING = me.Padding.all(15)
_DEFAULT_BORDER = me.Border.all(
  me.BorderSide(color="#e0e0e0", width=1, style="solid")
)

_STYLE_INPUT_WIDTH = me.Style(width="100%")
_STYLE_SLIDER_INPUT_BOX = me.Style(display="flex", flex_wrap="wrap")
_STYLE_SLIDER_WRAP = me.Style(flex_grow=1)
_STYLE_SLIDER_LABEL = me.Style(padding=me.Padding(bottom=10))
_STYLE_SLIDER = me.Style(width="90%")
_STYLE_SLIDER_INPUT = me.Style(width=75)

_STYLE_STOP_SEQUENCE_BOX = me.Style(display="flex")
_STYLE_STOP_SEQUENCE_WRAP = me.Style(flex_grow=1)

_STYLE_CONTAINER = me.Style(
  display="grid",
  grid_template_columns="5fr 2fr",
  grid_template_rows="auto 5fr",
  height="100vh",
)

_STYLE_MAIN_HEADER = me.Style(
  border=_DEFAULT_BORDER, padding=me.Padding.all(15)
)

_STYLE_MAIN_COLUMN = me.Style(
  border=_DEFAULT_BORDER,
  padding=me.Padding.all(15),
  overflow_y="scroll",
)

_STYLE_CONFIG_COLUMN = me.Style(
  border=_DEFAULT_BORDER,
  padding=me.Padding.all(15),
  overflow_y="scroll",
)

_STYLE_TITLE_BOX = me.Style(display="inline-block")

_STYLE_CONFIG_HEADER = me.Style(
  border=_DEFAULT_BORDER, padding=me.Padding.all(10)
)

_STYLE_STOP_SEQUENCE_CHIP = me.Style(margin=me.Margin.all(3))

_STYLE_MODAL_CONTAINER = me.Style(
  background="#fff",
  margin=me.Margin.symmetric(vertical="0", horizontal="auto"),
  width="min(1024px, 100%)",
  box_sizing="content-box",
  height="100vh",
  overflow_y="scroll",
  box_shadow=("0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"),
)

_STYLE_MODAL_CONTENT = me.Style(margin=me.Margin.all(30))

_STYLE_CODE_BOX = me.Style(
  font_size=13,
  margin=me.Margin.symmetric(vertical=10, horizontal=0),
  padding=me.Padding.all(10),
  border=me.Border.all(me.BorderSide(color="#e0e0e0", width=1, style="solid")),
)
</page>

<page url=''>
import base64

import mesop as me


@me.stateclass
class State:
  file: me.UploadedFile


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/uploader",
)
def app():
  state = me.state(State)
  with me.box(style=me.Style(padding=me.Padding.all(15))):
    me.uploader(
      label="Upload Image",
      accepted_file_types=["image/jpeg", "image/png"],
      on_upload=handle_upload,
      type="flat",
      color="primary",
      style=me.Style(font_weight="bold"),
    )

    if state.file.size:
      with me.box(style=me.Style(margin=me.Margin.all(10))):
        me.text(f"File name: {state.file.name}")
        me.text(f"File size: {state.file.size}")
        me.text(f"File type: {state.file.mime_type}")

      with me.box(style=me.Style(margin=me.Margin.all(10))):
        me.image(src=_convert_contents_data_url(state.file))


def handle_upload(event: me.UploadEvent):
  state = me.state(State)
  state.file = event.file


def _convert_contents_data_url(file: me.UploadedFile) -> str:
  return (
    f"data:{file.mime_type};base64,{base64.b64encode(file.getvalue()).decode()}"
  )
</page>

<page url=''>
from dataclasses import dataclass, field

import mesop as me

_INTRO_TEXT = """
# Mesop Markdown Editor Example

This example shows how to make a simple markdown editor.
""".strip()


@dataclass(kw_only=True)
class Note:
  """Content of note."""

  content: str = ""


@me.stateclass
class State:
  notes: list[Note] = field(default_factory=lambda: [Note(content=_INTRO_TEXT)])
  selected_note_index: int = 0
  selected_note_content: str = _INTRO_TEXT
  show_preview: bool = True


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/markdown_editor",
  title="Markdown Editor",
)
def page():
  state = me.state(State)

  with me.box(style=_style_container(state.show_preview)):
    # Note list column
    with me.box(style=_STYLE_NOTES_NAV):
      # Toolbar
      with me.box(style=_STYLE_TOOLBAR):
        with me.content_button(on_click=on_click_new):
          with me.tooltip(message="New note"):
            me.icon(icon="add_notes")
        with me.content_button(on_click=on_click_hide):
          with me.tooltip(
            message="Hide preview" if state.show_preview else "Show preview"
          ):
            me.icon(icon="hide_image")

      # Note list
      for index, note in enumerate(state.notes):
        with me.box(
          key=f"note-{index}",
          on_click=on_click_note,
          style=_style_note_row(index == state.selected_note_index),
        ):
          me.text(_render_note_excerpt(note.content))

    # Markdown Editor Column
    with me.box(style=_STYLE_EDITOR):
      me.native_textarea(
        value=state.selected_note_content,
        style=_STYLE_TEXTAREA,
        on_input=on_text_input,
      )

    # Markdown Preview Column
    if state.show_preview:
      with me.box(style=_STYLE_PREVIEW):
        if state.selected_note_index < len(state.notes):
          me.markdown(state.notes[state.selected_note_index].content)


# HELPERS

_EXCERPT_CHAR_LIMIT = 90


def _render_note_excerpt(content: str) -> str:
  if len(content) <= _EXCERPT_CHAR_LIMIT:
    return content
  return content[:_EXCERPT_CHAR_LIMIT] + "..."


# EVENT HANDLERS


def on_click_new(e: me.ClickEvent):
  state = me.state(State)
  # Need to update the initial value of the editor text area so we can
  # trigger a diff to reset the editor to empty. Need to yield this change.
  # for this to work.
  state.selected_note_content = state.notes[state.selected_note_index].content
  yield
  # Reset the initial value of the editor text area to empty since the new note
  # has no content.
  state.selected_note_content = ""
  state.notes.append(Note())
  state.selected_note_index = len(state.notes) - 1
  yield


def on_click_hide(e: me.ClickEvent):
  """Hides/Shows preview Markdown pane."""
  state = me.state(State)
  state.show_preview = bool(not state.show_preview)


def on_click_note(e: me.ClickEvent):
  """Selects a note from the note list."""
  state = me.state(State)
  note_id = int(e.key.replace("note-", ""))
  note = state.notes[note_id]
  state.selected_note_index = note_id
  state.selected_note_content = note.content


def on_text_input(e: me.InputEvent):
  """Captures text in editor."""
  state = me.state(State)
  state.notes[state.selected_note_index].content = e.value


# STYLES

_BACKGROUND_COLOR = "#fafafa"
_FONT_COLOR = "#555"
_NOTE_ROW_FONT_COLOR = "#777"
_NOTE_ROW_FONT_SIZE = "14px"
_SELECTED_ROW_BACKGROUND_COLOR = "#dee3eb"
_DEFAULT_BORDER_STYLE = me.BorderSide(width=1, style="solid", color="#bbb")


def _style_container(show_preview: bool = True) -> me.Style:
  return me.Style(
    background=_BACKGROUND_COLOR,
    color=_FONT_COLOR,
    display="grid",
    grid_template_columns="2fr 4fr 4fr" if show_preview else "2fr 8fr",
    height="100vh",
  )


def _style_note_row(selected: bool = False) -> me.Style:
  return me.Style(
    color=_NOTE_ROW_FONT_COLOR,
    font_size=_NOTE_ROW_FONT_SIZE,
    background=_SELECTED_ROW_BACKGROUND_COLOR if selected else "none",
    padding=me.Padding.all(10),
    border=me.Border(bottom=_DEFAULT_BORDER_STYLE),
    height="100px",
    overflow_x="hidden",
    overflow_y="hidden",
  )


_STYLE_NOTES_NAV = me.Style(overflow_y="scroll", padding=me.Padding.all(15))


_STYLE_TOOLBAR = me.Style(
  padding=me.Padding.all(5),
  border=me.Border(bottom=_DEFAULT_BORDER_STYLE),
)


_STYLE_EDITOR = me.Style(
  overflow_y="hidden",
  padding=me.Padding(left=20, right=15, top=20, bottom=0),
  border=me.Border(
    left=_DEFAULT_BORDER_STYLE,
    right=_DEFAULT_BORDER_STYLE,
  ),
)


_STYLE_PREVIEW = me.Style(
  overflow_y="scroll", padding=me.Padding.symmetric(vertical=0, horizontal=20)
)


_STYLE_TEXTAREA = me.Style(
  color=_FONT_COLOR,
  background=_BACKGROUND_COLOR,
  outline="none",  # Hides focus border
  border=me.Border.all(me.BorderSide(style="none")),
  width="100%",
  height="100%",
)
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/badge",
)
def app():
  with me.box(
    style=me.Style(
      display="block",
      padding=me.Padding(top=16, right=16, bottom=16, left=16),
      height=50,
      width=30,
    )
  ):
    with me.badge(content="1", size="medium"):
      me.text(text="text with badge")
</page>

<page url=''>
import mesop as me
import mesop.labs as mel


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/text_to_text",
  title="Text to Text Example",
)
def app():
  mel.text_to_text(
    upper_case_stream,
    title="Text to Text Example",
  )


def upper_case_stream(s: str):
  return "Echo: " + s
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/tooltip",
)
def app():
  with me.tooltip(message="Tooltip message"):
    me.text(text="Hello, World")
</page>

<page url=''>
"""Pure Mesop Table built using CSS Grid.

Functionality:

- Column sorting
- Header styles
- Row styles
- Cell styles
- Cell templating
- Row click
- Expandable rows
- Sticky header
- Filtering (technically not built-in to the grid table component)

TODOs:

- Pagination
- Sticky column
- Control column width
- Column filtering within grid table
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Callable, Literal, Protocol

import pandas as pd

import mesop as me

df = pd.DataFrame(
  data={
    "NA": [pd.NA, pd.NA, pd.NA],
    "Index": [3, 2, 1],
    "Bools": [True, False, True],
    "Ints": [101, 90, -55],
    "Floats": [1002.3, 4.5, -1050203.021],
    "Date Times": [
      pd.Timestamp("20180310"),
      pd.Timestamp("20230310"),
      datetime(2023, 1, 1, 12, 12, 1),
    ],
    "Strings": ["Hello", "World", "!"],
  }
)

SortDirection = Literal["asc", "desc"]


@me.stateclass
class State:
  expanded_df_row_index: int | None = None
  sort_column: str
  sort_direction: SortDirection = "asc"
  string_output: str
  table_filter: str
  theme: str = "light"


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/grid_table",
)
def app():
  state = me.state(State)

  with me.box(style=me.Style(margin=me.Margin.all(30))):
    me.select(
      label="Theme",
      options=[
        me.SelectOption(label="Light", value="light"),
        me.SelectOption(label="Dark", value="dark"),
      ],
      on_selection_change=on_theme_changed,
    )

    # Simple example of filtering a data table. This is implemented separately of the
    # grid table component. For simplicity, we only filter against a single column.
    me.input(
      label="Filter by Strings column",
      style=me.Style(width="100%"),
      on_blur=on_filter_by_strings,
      on_enter=on_filter_by_strings,
    )

    # Grid Table demonstrating all features.
    grid_table(
      get_data_frame(),
      header_config=GridTableHeader(sticky=True),
      on_click=on_table_cell_click,
      on_sort=on_table_sort,
      row_config=GridTableRow(
        columns={
          "Bools": GridTableColumn(component=bool_component),
          "Date Times": GridTableColumn(component=date_component),
          "Floats": GridTableColumn(component=floats_component),
          "Ints": GridTableColumn(style=ints_style, sortable=True),
          "Strings": GridTableColumn(
            component=strings_component, sortable=True
          ),
        },
        expander=GridTableExpander(
          component=expander,
          df_row_index=state.expanded_df_row_index,
        ),
      ),
      sort_column=state.sort_column,
      sort_direction=state.sort_direction,
      theme=GridTableThemeLight(striped=True)
      if state.theme == "light"
      else GridTableThemeDark(striped=True),
    )

    # Used for demonstrating "table button" click example.
    if state.string_output:
      with me.box(
        style=me.Style(
          background="#ececec",
          color="#333",
          margin=me.Margin(top=20),
          padding=me.Padding.all(15),
        )
      ):
        me.text(f"You clicked button: {state.string_output}")


@dataclass(kw_only=True)
class GridTableHeader:
  """Configuration for the table header

  Attributes:

    sticky: Enables sticky headers
    style: Overrides default header styles
  """

  sticky: bool = False
  style: Callable | None = None


@dataclass(kw_only=True)
class GridTableColumn:
  """Configuration for a table column

  Attributes:

    component: Custom rendering for the table cell
    sortable: Whether this column can be sorted or not
    style: Custom styling for the table cell
  """

  component: Callable | None = None
  sortable: bool = False
  style: Callable | None = None


@dataclass(kw_only=True)
class GridTableExpander:
  """Configuration for expander table row

  Currently only one row can be expanded at a time.

  Attributes:

    component: Custom rendering for the table row
    df_row_index: DataFrame row that is expanded.
    style: Custom styling for the expanded row
  """

  component: Callable | None = None
  df_row_index: int | None = None
  style: Callable | None = None


@dataclass(kw_only=True)
class GridTableRow:
  """Configuration for the table's rows.

  Attributes:

    columns: A map of column name to column specific configuration
    expander: Configuration for expanded row
    style: Custom styles at the row level.
  """

  columns: dict[str, GridTableColumn] = field(default_factory=lambda: {})
  expander: GridTableExpander = field(
    default_factory=lambda: GridTableExpander()
  )
  style: Callable | None = None


@dataclass(kw_only=True)
class GridTableCellMeta:
  """Metadata that is passed into style/component/expander callables.

  This metadata can be used to display things in custom ways based on the data.
  """

  df_row_index: int
  df_col_index: int
  name: str
  row_index: int
  value: Any


class GridTableTheme(Protocol):
  """Interface for theming the grid table"""

  def header(self, sortable: bool = False) -> me.Style:
    return me.Style()

  def sort_icon(self, current_column: str, sort_column: str) -> me.Style:
    return me.Style()

  def cell(self, cell_meta: GridTableCellMeta) -> me.Style:
    return me.Style()

  def expander(self, df_row_index: int) -> me.Style:
    return me.Style()


class GridTableThemeDark(GridTableTheme):
  _HEADER_BG: str = "#28313e"
  _CELL_BG: str = "#141d2c"
  _CELL_BG_ALT: str = "#02060c"
  _COLOR: str = "#fff"
  _PADDING: me.Padding = me.Padding.all(10)
  _BORDER: me.Border = me.Border.all(
    me.BorderSide(width=1, style="solid", color="rgba(255, 255, 255, 0.16)")
  )

  def __init__(self, striped: bool = False):
    self.striped = striped

  def header(self, sortable: bool = False) -> me.Style:
    return me.Style(
      background=self._HEADER_BG,
      color=self._COLOR,
      cursor="pointer" if sortable else "default",
      padding=self._PADDING,
      border=self._BORDER,
    )

  def sort_icon(self, current_column: str, sort_column: str) -> me.Style:
    return me.Style(
      color="rgba(255, 255, 255, .8)"
      if sort_column == current_column
      else "rgba(255, 255, 255, .4)",
      # Hack to make the icon align correctly. Will break if user changes the
      # font size with custom styles.
      height=16,
    )

  def cell(self, cell_meta: GridTableCellMeta) -> me.Style:
    return me.Style(
      background=self._CELL_BG_ALT
      if self.striped and cell_meta.row_index % 2
      else self._CELL_BG,
      color=self._COLOR,
      padding=self._PADDING,
      border=self._BORDER,
    )

  def expander(self, df_row_index: int) -> me.Style:
    return me.Style(
      background=self._CELL_BG,
      color=self._COLOR,
      padding=self._PADDING,
      border=self._BORDER,
    )


class GridTableThemeLight(GridTableTheme):
  _HEADER_BG: str = "#fff"
  _CELL_BG: str = "#fff"
  _CELL_BG_ALT: str = "#f6f6f6"
  _COLOR: str = "#000"
  _PADDING: me.Padding = me.Padding.all(10)
  _HEADER_BORDER: me.Border = me.Border(
    bottom=me.BorderSide(width=1, style="solid", color="#b2b2b2")
  )
  _CELL_BORDER: me.Border = me.Border(
    bottom=me.BorderSide(width=1, style="solid", color="#d9d9d9")
  )

  def __init__(self, striped: bool = False):
    self.striped = striped

  def header(self, sortable: bool = False) -> me.Style:
    return me.Style(
      background=self._HEADER_BG,
      color=self._COLOR,
      cursor="pointer" if sortable else "default",
      font_weight="bold",
      padding=self._PADDING,
      border=self._HEADER_BORDER,
    )

  def sort_icon(self, current_column: str, sort_column: str) -> me.Style:
    return me.Style(
      color="rgba(0, 0, 0, .8)"
      if sort_column == current_column
      else "rgba(0, 0, 0, .4)",
      # Hack to make the icon align correctly. Will break if user changes the
      # font size with custom styles.
      height=18,
    )

  def cell(self, cell_meta: GridTableCellMeta) -> me.Style:
    return me.Style(
      background=self._CELL_BG_ALT
      if self.striped and cell_meta.row_index % 2
      else self._CELL_BG,
      color=self._COLOR,
      padding=self._PADDING,
      border=self._CELL_BORDER,
    )

  def expander(self, df_row_index: int) -> me.Style:
    return me.Style(
      background=self._CELL_BG,
      color=self._COLOR,
      padding=self._PADDING,
      border=self._CELL_BORDER,
    )


def get_data_frame():
  """Helper function to get a sorted/filtered version of the main data frame.

  One drawback of this approach is that we sort/filter the main data frame with every
  refresh, which may not be efficient for larger data frames.
  """
  state = me.state(State)

  # Sort the data frame if sorting is enabled.
  if state.sort_column:
    sorted_df = df.sort_values(
      by=state.sort_column, ascending=state.sort_direction == "asc"
    )
  else:
    sorted_df = df

  # Simple filtering by the Strings column.
  if state.table_filter:
    return sorted_df[
      sorted_df["Strings"].str.lower().str.contains(state.table_filter.lower())
    ]
  else:
    return sorted_df


def on_theme_changed(e: me.SelectSelectionChangeEvent):
  """Changes the theme of the grid table"""
  state = me.state(State)
  state.theme = e.value


def on_filter_by_strings(e: me.InputBlurEvent | me.InputEnterEvent):
  """Saves the filtering string to be used in `get_data_frame`"""
  state = me.state(State)
  state.table_filter = e.value


def on_table_cell_click(e: me.ClickEvent):
  """If the table cell is clicked, show the expanded content."""
  state = me.state(State)
  df_row_index, _ = map(int, e.key.split("-"))
  if state.expanded_df_row_index == df_row_index:
    state.expanded_df_row_index = None
  else:
    state.expanded_df_row_index = df_row_index


def on_table_sort(e: me.ClickEvent):
  """Handles the table sort event by saving the sort information to be used in `get_data_frame`"""
  state = me.state(State)
  column, direction = e.key.split("-")
  if state.sort_column == column:
    state.sort_direction = "asc" if direction == "desc" else "desc"
  else:
    state.sort_direction = direction  # type: ignore
  state.sort_column = column


def expander(df_row_index: int):
  """Rendering logic for expanded row.

  Here we just display the row data in two columns as text inputs.

  But you can do more advanced things, such as:

  - rendering another table inside the table
  - fetching data to show drill down data
  - add a form for data entry
  """
  columns = list(df.columns)
  with me.box(style=me.Style(padding=me.Padding.all(15))):
    me.text(f"Expanded row: {df_row_index}", type="headline-5")
    with me.box(
      style=me.Style(
        display="grid",
        grid_template_columns="repeat(2, 1fr)",
        gap=10,
      )
    ):
      for index, col in enumerate(df.iloc[df_row_index]):
        me.input(
          label=columns[index], value=str(col), style=me.Style(width="100%")
        )


def on_click_strings(e: me.ClickEvent):
  """Click event for the cell button example."""
  state = me.state(State)
  state.string_output = e.key


def strings_component(meta: GridTableCellMeta):
  """Example of a cell rendering a button with a click event.

  Note that the behavior is slightly buggy if there is also a cell click event. This
  event will fire, but so will the cell click event. This is due to
  https://github.com/google/mesop/issues/268.
  """
  me.button(
    meta.value,
    key=meta.value,
    on_click=on_click_strings,
    style=me.Style(
      border_radius=3,
      background="#334053",
      border=me.Border.all(
        me.BorderSide(width=1, style="solid", color="rgba(255, 255, 255, 0.16)")
      ),
      font_weight="bold",
      color="#fff",
    ),
  )


def bool_component(meta: GridTableCellMeta):
  """Example of a cell rendering icons based on the cell value."""
  if meta.value:
    me.icon("check_circle", style=me.Style(color="green"))
  else:
    me.icon("cancel", style=me.Style(color="red"))


def ints_style(meta: GridTableCellMeta) -> me.Style:
  """Example of a cell style based on the integer value."""
  return me.Style(
    background="#29a529" if meta.value > 0 else "#db4848",
    color="#fff",
    padding=me.Padding.all(10),
    border=me.Border.all(
      me.BorderSide(width=1, style="solid", color="rgba(255, 255, 255, 0.16)")
    ),
  )


def floats_component(meta: GridTableCellMeta):
  """Example of a cell rendering using string formatting."""
  me.text(f"${meta.value:,.2f}")


def date_component(meta: GridTableCellMeta):
  """Example of a cell rendering using custom date formatting."""
  me.text(meta.value.strftime("%b %d, %Y at %I:%M %p"))


@me.component
def grid_table(
  data,
  *,
  header_config: GridTableHeader | None = None,
  on_click: Callable | None = None,
  on_sort: Callable | None = None,
  row_config: GridTableRow | None = None,
  sort_column: str = "",
  sort_direction: SortDirection = "asc",
  theme: Any
  | None = None,  # Using Any since Pydantic complains about using a class.
):
  """Grid table component.

  Args:

    data: Pandas data frame
    header_config: Configuration for the table header
    on_click: Click event that fires when a cell is clicked
    on_sort: Click event that fires when a sortable header column is clicked
    row_config: Configuration for the tables's rows
    sort_column: Current sort column
    sort_direction: Current sort direction
    theme: Table theme
  """
  with me.box(
    style=me.Style(
      display="grid",
      # This creates a grid with "equal" sized rows based on the columns. We may want to
      # override this to allow custom widths.
      grid_template_columns=f"repeat({len(data.columns)}, 1fr)",
    )
  ):
    _theme: GridTableTheme = GridTableThemeLight()
    if theme:
      _theme = theme

    if not header_config:
      header_config = GridTableHeader()

    if not row_config:
      row_config = GridTableRow()

    col_index_name_map = {}

    # Render the table header
    for col_index, col in enumerate(data.columns):
      col_index_name_map[col_index] = col
      sortable_col = row_config.columns.get(col, GridTableColumn()).sortable
      with me.box(
        # Sort key format: ColumName-SortDirection
        key=_make_sort_key(col, sort_column, sort_direction),
        style=_make_header_style(
          theme=_theme, header_config=header_config, sortable=sortable_col
        ),
        on_click=on_sort if sortable_col else None,
      ):
        with me.box(
          style=me.Style(
            display="flex",
            align_items="center",
          )
        ):
          if sortable_col:
            # Render sorting icons for sortable columns
            #
            # If column is sortable and not selected, always render an up arrow that is de-emphasized
            # If column is sortable and selected, render the arrow with emphasis
            # If the column is newly selected, render the up arrow to sort ascending
            # If the column is selected and reselected, render the opposite arrow
            me.icon(
              "arrow_downward"
              if sort_column == col and sort_direction == "desc"
              else "arrow_upward",
              style=_theme.sort_icon(col, sort_column),
            )
          me.text(col)

    # Render table rows
    for row_index, row in enumerate(data.itertuples(name=None)):
      for col_index, col in enumerate(row[1:]):
        cell_config = row_config.columns.get(
          col_index_name_map[col_index], GridTableColumn()
        )
        cell_meta = GridTableCellMeta(
          df_row_index=row[0],
          df_col_index=col_index,
          name=col_index_name_map[col_index],
          row_index=row_index,
          value=col,
        )
        with me.box(
          # Store the df row index and df col index for the cell click event so we know
          # which cell is clicked.
          key=f"{row[0]}-{col_index}",
          style=_make_cell_style(
            theme=_theme,
            cell_meta=cell_meta,
            column=cell_config,
            row_style=row_config.style,
          ),
          on_click=on_click,
        ):
          if cell_config.component:
            # Render custom cell markup
            cell_config.component(cell_meta)
          else:
            me.text(str(col))

      # Render the expander if it's enabled and a row has been selected.
      if (
        row_config.expander.component
        and row_config.expander.df_row_index == row[0]
      ):
        with me.box(
          style=_make_expander_style(
            df_row_index=row[0],
            col_span=len(data.columns),
            expander_style=row_config.expander.style,
            theme=_theme,
          )
        ):
          row_config.expander.component(row[0])


def _make_header_style(
  *, theme: GridTableTheme, header_config: GridTableHeader, sortable: bool
) -> me.Style:
  """Renders the header style

  Precendence of styles:

  - Header style override
  - Theme default
  """

  # Default styles
  style = theme.header(sortable)
  if header_config.style:
    style = header_config.style(sortable)

  if header_config.sticky:
    style.position = "sticky"
    style.top = 0

  return style


def _make_sort_key(col: str, sort_column: str, sort_direction: SortDirection):
  if col == sort_column:
    return f"{sort_column}-{sort_direction}"
  return f"{col}-asc"


def _make_cell_style(
  *,
  theme: GridTableTheme,
  cell_meta: GridTableCellMeta,
  column: GridTableColumn,
  row_style: Callable | None = None,
) -> me.Style:
  """Renders the cell style

  Precendence of styles:

  - Cell style override
  - Row style override
  - Theme Default
  """
  style = theme.cell(cell_meta)

  if column.style:
    style = column.style(cell_meta)
  elif row_style:
    style = row_style(cell_meta)

  return style


def _make_expander_style(
  *,
  theme: GridTableTheme,
  df_row_index: int,
  col_span: int,
  expander_style: Callable | None = None,
) -> me.Style:
  """Renders the expander style

  Precendence of styles:

  - Cell style override
  - Theme default
  """
  style = theme.expander(df_row_index)
  if expander_style:
    style = expander_style(df_row_index)

  style.grid_column = f"span {col_span}"

  return style
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  initial_input_value: str = "50.0"
  initial_slider_value: float = 50.0
  slider_value: float = 50.0


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/slider",
)
def app():
  state = me.state(State)
  with me.box(style=me.Style(display="flex", flex_direction="column")):
    me.input(
      label="Slider value", value=state.initial_input_value, on_input=on_input
    )
    me.slider(on_value_change=on_value_change, value=state.initial_slider_value)
    me.text(text=f"Value: {me.state(State).slider_value}")


def on_value_change(event: me.SliderValueChangeEvent):
  state = me.state(State)
  state.slider_value = event.value
  state.initial_input_value = str(state.slider_value)


def on_input(event: me.InputEvent):
  state = me.state(State)
  state.initial_slider_value = float(event.value)
  state.slider_value = state.initial_slider_value
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/button",
)
def main():
  me.text("Button types:", style=me.Style(margin=me.Margin(bottom=12)))
  with me.box(style=me.Style(display="flex", flex_direction="row", gap=12)):
    me.button("default")
    me.button("raised", type="raised")
    me.button("flat", type="flat")
    me.button("stroked", type="stroked")

  me.text("Button colors:", style=me.Style(margin=me.Margin(bottom=12)))
  with me.box(style=me.Style(display="flex", flex_direction="row", gap=12)):
    me.button("default", type="flat")
    me.button("primary", color="primary", type="flat")
    me.button("secondary", color="accent", type="flat")
    me.button("warn", color="warn", type="flat")
</page>

<page url=''>
import random
import time

import mesop as me
import mesop.labs as mel


def on_load(e: me.LoadEvent):
  me.set_theme_mode("system")


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/chat",
  title="Mesop Demo Chat",
  on_load=on_load,
)
def page():
  mel.chat(transform, title="Mesop Demo Chat", bot_user="Mesop Bot")


def transform(input: str, history: list[mel.ChatMessage]):
  for line in random.sample(LINES, random.randint(3, len(LINES) - 1)):
    time.sleep(0.3)
    yield line + " "


LINES = [
  "Mesop is a Python-based UI framework designed to simplify web UI development for engineers without frontend experience.",
  "It leverages the power of the Angular web framework and Angular Material components, allowing rapid construction of web demos and internal tools.",
  "With Mesop, developers can enjoy a fast build-edit-refresh loop thanks to its hot reload feature, making UI tweaks and component integration seamless.",
  "Deployment is straightforward, utilizing standard HTTP technologies.",
  "Mesop's component library aims for comprehensive Angular Material component coverage, enhancing UI flexibility and composability.",
  "It supports custom components for specific use cases, ensuring developers can extend its capabilities to fit their unique requirements.",
  "Mesop's roadmap includes expanding its component library and simplifying the onboarding processs.",
]
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  selected_values: list[str]


def on_selection_change(e: me.SelectSelectionChangeEvent):
  s = me.state(State)
  s.selected_values = e.values


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/select_demo",
)
def app():
  me.text(text="Select")
  me.select(
    label="Select",
    options=[
      me.SelectOption(label="label 1", value="value1"),
      me.SelectOption(label="label 2", value="value2"),
      me.SelectOption(label="label 3", value="value3"),
    ],
    on_selection_change=on_selection_change,
    style=me.Style(width=500),
    multiple=True,
  )
  s = me.state(State)
  me.text(text="Selected values: " + ", ".join(s.selected_values))
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  input: str = ""


def on_blur(e: me.InputBlurEvent):
  state = me.state(State)
  state.input = e.value


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/input",
)
def app():
  s = me.state(State)
  me.input(label="Basic input", on_blur=on_blur)
  me.text(text=s.input)
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/text",
)
def text():
  me.text(text="headline-1: Hello, world!", type="headline-1")
  me.text(text="headline-2: Hello, world!", type="headline-2")
  me.text(text="headline-3: Hello, world!", type="headline-3")
  me.text(text="headline-4: Hello, world!", type="headline-4")
  me.text(text="headline-5: Hello, world!", type="headline-5")
  me.text(text="headline-6: Hello, world!", type="headline-6")
  me.text(text="subtitle-1: Hello, world!", type="subtitle-1")
  me.text(text="subtitle-2: Hello, world!", type="subtitle-2")
  me.text(text="body-1: Hello, world!", type="body-1")
  me.text(text="body-2: Hello, world!", type="body-2")
  me.text(text="caption: Hello, world!", type="caption")
  me.text(text="button: Hello, world!", type="button")
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/chat_inputs",
)
def app():
  with me.box(style=CONTENT_STYLE):
    subtle_chat_input()
    elevated_chat_input()

    me.textarea(
      placeholder="Default chat input",
      style=me.Style(width="100%"),
      rows=2,
    )


@me.component
def subtle_chat_input():
  with me.box(
    style=me.Style(
      border_radius=16,
      padding=me.Padding.all(8),
      background=BACKGROUND_COLOR,
      display="flex",
      width="100%",
    )
  ):
    with me.box(
      style=me.Style(
        flex_grow=1,
      )
    ):
      me.native_textarea(
        autosize=True,
        min_rows=4,
        placeholder="Subtle chat input",
        style=me.Style(
          padding=me.Padding(top=16, left=16),
          background=BACKGROUND_COLOR,
          outline="none",
          width="100%",
          overflow_y="auto",
          border=me.Border.all(
            me.BorderSide(style="none"),
          ),
        ),
      )
    with me.content_button(type="icon"):
      me.icon("upload")
    with me.content_button(type="icon"):
      me.icon("photo")
    with me.content_button(type="icon"):
      me.icon("send")


@me.component
def elevated_chat_input():
  with me.box(
    style=me.Style(
      padding=me.Padding.all(8),
      background="white",
      display="flex",
      width="100%",
      border=me.Border.all(
        me.BorderSide(width=0, style="solid", color="black")
      ),
      box_shadow="0 10px 20px #0000000a, 0 2px 6px #0000000a, 0 0 1px #0000000a",
    )
  ):
    with me.box(
      style=me.Style(
        flex_grow=1,
      )
    ):
      me.native_textarea(
        autosize=True,
        min_rows=4,
        placeholder="Elevated chat input",
        style=me.Style(
          font_family="monospace",
          padding=me.Padding(top=16, left=16),
          background="white",
          outline="none",
          width="100%",
          overflow_y="auto",
          border=me.Border.all(
            me.BorderSide(style="none"),
          ),
        ),
      )
    with me.content_button(type="icon"):
      me.icon("upload")
    with me.content_button(type="icon"):
      me.icon("photo")
    with me.content_button(type="icon"):
      me.icon("send")


BACKGROUND_COLOR = "#e2e8f0"

CONTENT_STYLE = me.Style(padding=me.Padding.all(16), gap=16, display="grid")
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  radio_value: str = "2"


def on_change(event: me.RadioChangeEvent):
  s = me.state(State)
  s.radio_value = event.value


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/radio",
)
def app():
  s = me.state(State)
  me.text("Horizontal radio options")
  me.radio(
    on_change=on_change,
    options=[
      me.RadioOption(label="Option 1", value="1"),
      me.RadioOption(label="Option 2", value="2"),
    ],
    value=s.radio_value,
  )
  me.text(text="Selected radio value: " + s.radio_value)
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/audio",
)
def app():
  """
  In order to autoplay audio, set the `autoplay` attribute to `True`,
  Note that there are autoplay restrictions in modern browsers, including Chrome,
  are designed to prevent audio or video from playing automatically without user interaction.
  This is intended to improve user experience and reduce unwanted interruptions.
  You can check the [autoplay ability of your application](https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide#autoplay_availability)
  """
  me.audio(
    src="https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3",
    # autoplay=True
  )
</page>

<page url=''>
from datetime import datetime

import numpy as np
import pandas as pd

import mesop as me


@me.stateclass
class State:
  selected_cell: str = "No cell selected."


df = pd.DataFrame(
  data={
    "NA": [pd.NA, pd.NA, pd.NA],
    "Index": [3, 2, 1],
    "Bools": [True, False, np.bool_(True)],
    "Ints": [101, 90, np.int64(-55)],
    "Floats": [2.3, 4.5, np.float64(-3.000000003)],
    "Strings": ["Hello", "World", "!"],
    "Date Times": [
      pd.Timestamp("20180310"),
      pd.Timestamp("20230310"),
      datetime(2023, 1, 1, 12, 12, 1),
    ],
  }
)


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/table",
)
def app():
  state = me.state(State)

  with me.box(style=me.Style(padding=me.Padding.all(10), width=500)):
    me.table(
      df,
      on_click=on_click,
      header=me.TableHeader(sticky=True),
      columns={
        "NA": me.TableColumn(sticky=True),
        "Index": me.TableColumn(sticky=True),
      },
    )

  with me.box(
    style=me.Style(
      background="#ececec",
      margin=me.Margin.all(10),
      padding=me.Padding.all(10),
    )
  ):
    me.text(state.selected_cell)


def on_click(e: me.TableClickEvent):
  state = me.state(State)
  state.selected_cell = (
    f"Selected cell at col {e.col_index} and row {e.row_index} "
    f"with value {df.iat[e.row_index, e.col_index]!s}"
  )
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/progress_bar",
)
def app():
  me.text("Default progress bar")
  me.progress_bar()
</page>

<page url=''>
import random
import time
from dataclasses import dataclass
from typing import Literal

import mesop as me

Role = Literal["user", "assistant"]


@dataclass(kw_only=True)
class ChatMessage:
  """Chat message metadata."""

  role: Role = "user"
  content: str = ""
  edited: bool = False


@me.stateclass
class State:
  input: str
  output: list[ChatMessage]
  in_progress: bool
  rewrite: str
  rewrite_message_index: int
  preview_rewrite: str
  preview_original: str
  modal_open: bool


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/llm_rewriter",
  title="LLM Rewriter",
)
def page():
  state = me.state(State)

  # Modal
  with me.box(style=_make_modal_background_style(state.modal_open)):
    with me.box(style=_STYLE_MODAL_CONTAINER):
      with me.box(style=_STYLE_MODAL_CONTENT):
        me.textarea(
          label="Rewrite",
          style=_STYLE_INPUT_WIDTH,
          value=state.rewrite,
          on_input=on_rewrite_input,
        )
        with me.box():
          me.button(
            "Submit Rewrite",
            color="primary",
            type="flat",
            on_click=on_click_submit_rewrite,
          )
          me.button(
            "Cancel",
            on_click=on_click_cancel_rewrite,
          )
        with me.box(style=_STYLE_PREVIEW_CONTAINER):
          with me.box(style=_STYLE_PREVIEW_ORIGINAL):
            me.text("Original Message", type="headline-6")
            me.markdown(state.preview_original)

          with me.box(style=_STYLE_PREVIEW_REWRITE):
            me.text("Preview Rewrite", type="headline-6")
            me.markdown(state.preview_rewrite)

  # Chat UI
  with me.box(style=_STYLE_APP_CONTAINER):
    with me.box(style=_make_style_chat_ui_container(bool(_TITLE))):
      me.text(_TITLE, type="headline-5", style=_STYLE_TITLE)
      with me.box(style=_STYLE_CHAT_BOX):
        for index, msg in enumerate(state.output):
          with me.box(
            style=_make_style_chat_bubble_wrapper(msg.role),
            key=f"msg-{index}",
            on_click=on_click_rewrite_msg,
          ):
            if msg.role == _ROLE_ASSISTANT:
              me.text(
                _display_username(_BOT_USER_DEFAULT, msg.edited),
                style=_STYLE_CHAT_BUBBLE_NAME,
              )
            with me.box(style=_make_chat_bubble_style(msg.role, msg.edited)):
              if msg.role == _ROLE_USER:
                me.text(msg.content, style=_STYLE_CHAT_BUBBLE_PLAINTEXT)
              else:
                me.markdown(msg.content)
                with me.tooltip(message="Rewrite response"):
                  me.icon(icon="edit_note")

        if state.in_progress:
          with me.box(key="scroll-to", style=me.Style(height=300)):
            pass
      with me.box(style=_STYLE_CHAT_INPUT_BOX):
        with me.box(style=me.Style(flex_grow=1)):
          me.input(
            label=_LABEL_INPUT,
            # Workaround: update key to clear input.
            key=f"input-{len(state.output)}",
            on_input=on_chat_input,
            on_enter=on_click_submit_chat_msg,
            style=_STYLE_CHAT_INPUT,
          )
        with me.content_button(
          color="primary",
          type="flat",
          disabled=state.in_progress,
          on_click=on_click_submit_chat_msg,
          style=_STYLE_CHAT_BUTTON,
        ):
          me.icon(
            _LABEL_BUTTON_IN_PROGRESS if state.in_progress else _LABEL_BUTTON
          )


# Event Handlers


def on_chat_input(e: me.InputEvent):
  """Capture chat text input."""
  state = me.state(State)
  state.input = e.value


def on_rewrite_input(e: me.InputEvent):
  """Capture rewrite text input."""
  state = me.state(State)
  state.preview_rewrite = e.value


def on_click_rewrite_msg(e: me.ClickEvent):
  """Shows rewrite modal when a message is clicked.

  Edit this function to persist rewritten messages.
  """
  state = me.state(State)
  index = int(e.key.replace("msg-", ""))
  message = state.output[index]
  if message.role == _ROLE_USER or state.in_progress:
    return
  state.modal_open = True
  state.rewrite = message.content
  state.rewrite_message_index = index
  state.preview_original = message.content
  state.preview_rewrite = message.content


def on_click_submit_rewrite(e: me.ClickEvent):
  """Submits rewrite message."""
  state = me.state(State)
  state.modal_open = False
  message = state.output[state.rewrite_message_index]
  if message.content != state.preview_rewrite:
    message.content = state.preview_rewrite
    message.edited = True
  state.rewrite_message_index = 0
  state.rewrite = ""
  state.preview_original = ""
  state.preview_rewrite = ""


def on_click_cancel_rewrite(e: me.ClickEvent):
  """Hides rewrite modal."""
  state = me.state(State)
  state.modal_open = False
  state.rewrite_message_index = 0
  state.rewrite = ""
  state.preview_original = ""
  state.preview_rewrite = ""


def on_click_submit_chat_msg(e: me.ClickEvent | me.InputEnterEvent):
  """Handles submitting a chat message."""
  state = me.state(State)
  if state.in_progress or not state.input:
    return
  input = state.input
  state.input = ""
  yield

  output = state.output
  if output is None:
    output = []
  output.append(ChatMessage(role=_ROLE_USER, content=input))
  state.in_progress = True
  yield

  me.scroll_into_view(key="scroll-to")
  time.sleep(0.15)
  yield

  start_time = time.time()
  output_message = respond_to_chat(input, state.output)
  assistant_message = ChatMessage(role=_ROLE_ASSISTANT)
  output.append(assistant_message)
  state.output = output
  for content in output_message:
    assistant_message.content += content
    # TODO: 0.25 is an abitrary choice. In the future, consider making this adjustable.
    if (time.time() - start_time) >= 0.25:
      start_time = time.time()
      yield

  state.in_progress = False
  yield


# Transform function for processing chat messages.


def respond_to_chat(input: str, history: list[ChatMessage]):
  """Displays random canned text.

  Edit this function to process messages with a real chatbot/LLM.
  """
  lines = [
    (
      "Lorem ipsum dolor sit amet, consectetur adipiscing elit, "
      "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
    ),
    "Laoreet sit amet cursus sit amet dictum sit amet.",
    "At lectus urna duis convallis.",
    "A pellentesque sit amet porttitor eget.",
    "Mauris nunc congue nisi vitae suscipit tellus mauris a diam.",
    "Aliquet lectus proin nibh nisl condimentum id.",
    "Integer malesuada nunc vel risus commodo viverra maecenas accumsan.",
    "Tempor id eu nisl nunc mi.",
    "Id consectetur purus ut faucibus pulvinar.",
    "Mauris pharetra et ultrices neque ornare.",
    "Facilisis magna etiam tempor orci.",
    "Mauris pharetra et ultrices neque.",
    "Sit amet facilisis magna etiam tempor orci.",
    "Amet consectetur adipiscing elit pellentesque habitant morbi tristique.",
    "Egestas erat imperdiet sed euismod.",
    "Tincidunt praesent semper feugiat nibh sed pulvinar proin gravida.",
    "Habitant morbi tristique senectus et netus et malesuada.",
  ]
  for line in random.sample(lines, random.randint(3, len(lines) - 1)):
    yield line + " "


# Constants

_TITLE = "LLM Rewriter"

_ROLE_USER = "user"
_ROLE_ASSISTANT = "assistant"

_BOT_USER_DEFAULT = "mesop-bot"


# Styles

_COLOR_BACKGROUND = "#f0f4f8"
_COLOR_CHAT_BUBBLE_YOU = "#f2f2f2"
_COLOR_CHAT_BUBBLE_BOT = "#ebf3ff"
_COLOR_CHAT_BUUBBLE_EDITED = "#f2ebff"

_DEFAULT_PADDING = me.Padding.all(20)
_DEFAULT_BORDER_SIDE = me.BorderSide(
  width="1px", style="solid", color="#ececec"
)

_LABEL_BUTTON = "send"
_LABEL_BUTTON_IN_PROGRESS = "pending"
_LABEL_INPUT = "Enter your prompt"

_STYLE_INPUT_WIDTH = me.Style(width="100%")

_STYLE_APP_CONTAINER = me.Style(
  background=_COLOR_BACKGROUND,
  display="grid",
  height="100vh",
  grid_template_columns="repeat(1, 1fr)",
)
_STYLE_TITLE = me.Style(padding=me.Padding(left=10))
_STYLE_CHAT_BOX = me.Style(
  height="100%",
  overflow_y="scroll",
  padding=_DEFAULT_PADDING,
  margin=me.Margin(bottom=20),
  border_radius="10px",
  border=me.Border(
    left=_DEFAULT_BORDER_SIDE,
    right=_DEFAULT_BORDER_SIDE,
    top=_DEFAULT_BORDER_SIDE,
    bottom=_DEFAULT_BORDER_SIDE,
  ),
)
_STYLE_CHAT_INPUT = me.Style(width="100%")
_STYLE_CHAT_INPUT_BOX = me.Style(
  padding=me.Padding(top=30), display="flex", flex_direction="row"
)
_STYLE_CHAT_BUTTON = me.Style(margin=me.Margin(top=8, left=8))
_STYLE_CHAT_BUBBLE_NAME = me.Style(
  font_weight="bold",
  font_size="12px",
  padding=me.Padding(left=15, right=15, bottom=5),
)
_STYLE_CHAT_BUBBLE_PLAINTEXT = me.Style(margin=me.Margin.symmetric(vertical=15))

_STYLE_MODAL_CONTAINER = me.Style(
  background="#fff",
  margin=me.Margin.symmetric(vertical="0", horizontal="auto"),
  width="min(1024px, 100%)",
  box_sizing="content-box",
  height="100vh",
  overflow_y="scroll",
  box_shadow=("0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"),
)

_STYLE_MODAL_CONTENT = me.Style(margin=me.Margin.all(20))

_STYLE_PREVIEW_CONTAINER = me.Style(
  display="grid",
  grid_template_columns="repeat(2, 1fr)",
)

_STYLE_PREVIEW_ORIGINAL = me.Style(color="#777", padding=_DEFAULT_PADDING)

_STYLE_PREVIEW_REWRITE = me.Style(
  background=_COLOR_CHAT_BUUBBLE_EDITED, padding=_DEFAULT_PADDING
)


def _make_style_chat_ui_container(has_title: bool) -> me.Style:
  """Generates styles for chat UI container depending on if there is a title or not.

  Args:
    has_title: Whether the Chat UI is display a title or not.
  """
  return me.Style(
    display="grid",
    grid_template_columns="repeat(1, 1fr)",
    grid_template_rows="1fr 14fr 1fr" if has_title else "5fr 1fr",
    margin=me.Margin.symmetric(vertical=0, horizontal="auto"),
    width="min(1024px, 100%)",
    height="100vh",
    background="#fff",
    box_shadow=(
      "0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f"
    ),
    padding=me.Padding(top=20, left=20, right=20),
  )


def _make_style_chat_bubble_wrapper(role: Role) -> me.Style:
  """Generates styles for chat bubble position.

  Args:
    role: Chat bubble alignment depends on the role
  """
  align_items = "end" if role == _ROLE_USER else "start"
  return me.Style(
    display="flex",
    flex_direction="column",
    align_items=align_items,
  )


def _make_chat_bubble_style(role: Role, edited: bool) -> me.Style:
  """Generates styles for chat bubble.

  Args:
    role: Chat bubble background color depends on the role
    edited: Whether chat message was edited or not.
  """
  background = _COLOR_CHAT_BUBBLE_YOU
  if role == _ROLE_ASSISTANT:
    background = _COLOR_CHAT_BUBBLE_BOT
  if edited:
    background = _COLOR_CHAT_BUUBBLE_EDITED

  return me.Style(
    width="80%",
    font_size="13px",
    background=background,
    border_radius="15px",
    padding=me.Padding(right=15, left=15, bottom=3),
    margin=me.Margin(bottom=10),
    border=me.Border(
      left=_DEFAULT_BORDER_SIDE,
      right=_DEFAULT_BORDER_SIDE,
      top=_DEFAULT_BORDER_SIDE,
      bottom=_DEFAULT_BORDER_SIDE,
    ),
  )


def _make_modal_background_style(modal_open: bool) -> me.Style:
  """Makes style for modal background.

  Args:
    modal_open: Whether the modal is open.
  """
  return me.Style(
    display="block" if modal_open else "none",
    position="fixed",
    z_index=1000,
    width="100%",
    height="100%",
    overflow_x="auto",
    overflow_y="auto",
    background="rgba(0,0,0,0.4)",
  )


def _display_username(username: str, edited: bool = False) -> str:
  """Displays the username

  Args:
    username: Name of the user
    edited: Whether the message has been edited.
  """
  edited_text = " (edited)" if edited else ""
  return username + edited_text
</page>

<page url=''>
import time
from dataclasses import field

import mesop as me


@me.stateclass
class State:
  ex1_rgba: list[int] = field(default_factory=lambda: [255, 0, 0, 1])
  ex2_opacity: float = 1.0
  ex3_width: int
  ex4_left: int
  ex5_rotate_deg: int
  ex6_transforms_index: int = 0


TRANSFORM_OPERATIONS = [
  "none",
  "matrix(1, 2, 3, 4, 5, 6)",
  "translate(120px, 50%)",
  "scale(2, 0.5)",
  "rotate(0.5turn)",
  "skew(30deg, 20deg)",
  "scale(0.5) translate(-100%, -100%)",
]

DEFAULT_MARGIN = me.Style(margin=me.Margin.all(30))
BUTTON_MARGIN = me.Style(margin=me.Margin.symmetric(vertical=15))


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/basic_animation",
)
def app():
  state = me.state(State)

  with me.box(style=DEFAULT_MARGIN):
    me.text("Transform color", type="headline-5")
    me.text(
      "Changing the color can be used to indicate when a field has been updated."
    )
    me.button(
      "Transform",
      type="flat",
      on_click=transform_red_yellow,
      style=BUTTON_MARGIN,
    )
    with me.box(
      style=me.Style(
        background=f"rgba({','.join(map(str, state.ex1_rgba))})",
        width=100,
        height=100,
        margin=me.Margin.all(10),
      )
    ):
      me.text("Mesop")

  with me.box(style=DEFAULT_MARGIN):
    me.text("Fade in / Fade out", type="headline-5")
    me.text("Fading in/out can be useful for flash/toast components.")
    me.button(
      "Transform",
      type="flat",
      on_click=transform_fade_in_out,
      style=BUTTON_MARGIN,
    )
    with me.box(
      style=me.Style(
        background="red",
        opacity=state.ex2_opacity,
        width=100,
        height=100,
        margin=me.Margin.all(10),
      )
    ):
      me.text("Mesop")

  with me.box(style=DEFAULT_MARGIN):
    me.text("Resize", type="headline-5")
    me.text(
      "Could be used for things like progress bars or opening closing accordion/tabs."
    )
    me.button(
      "Transform", type="flat", on_click=transform_width, style=BUTTON_MARGIN
    )
    with me.box(
      style=me.Style(
        background="rgba(0,0,0,1)",
        width=300,
        height=20,
        margin=me.Margin.all(10),
      )
    ):
      with me.box(
        style=me.Style(
          background="rgba(255, 0, 0, 1)",
          width=str(state.ex3_width) + "%",
          height=20,
        )
      ):
        me.text("")

  with me.box(style=DEFAULT_MARGIN):
    me.text("Move", type="headline-5")
    me.text("Could be used for opening and closing sidebars.")
    me.button(
      "Transform", type="flat", on_click=transform_margin, style=BUTTON_MARGIN
    )
    with me.box():
      with me.box(
        style=me.Style(
          position="relative",
          background="rgba(255, 0, 0, 1)",
          left=state.ex4_left,
          width=30,
          height=30,
        )
      ):
        me.text("")

  with me.box(style=DEFAULT_MARGIN):
    me.text("Rotate", type="headline-5")
    me.text("Uses the rotate CSS property to emulate a rotation animation.")
    me.button(
      "Transform", type="flat", on_click=transform_rotate, style=BUTTON_MARGIN
    )
    with me.box():
      with me.box(
        style=me.Style(
          background="rgba(255, 0, 0, 1)",
          rotate=f"{state.ex5_rotate_deg}deg",
          width=100,
          height=100,
        )
      ):
        me.text("Mesop")

  with me.box(style=DEFAULT_MARGIN):
    me.text("Transform", type="headline-5")
    me.text("Apply a sequence of transformations.")
    me.button(
      "Transform",
      type="flat",
      on_click=transform_transform,
      style=BUTTON_MARGIN,
    )
    with me.box():
      with me.box(
        style=me.Style(
          background="rgba(255, 0, 0, 1)",
          transform=TRANSFORM_OPERATIONS[state.ex6_transforms_index],
          width=100,
          height=100,
        )
      ):
        me.text("Mesop")


def transform_red_yellow(e: me.ClickEvent):
  """Transform the color from red to yellow or yellow to red."""
  state = me.state(State)

  if state.ex1_rgba[1] == 0:
    while state.ex1_rgba[1] < 255:
      state.ex1_rgba[1] += 10
      yield
      time.sleep(0.1)
    state.ex1_rgba[1] = 255
    yield
  else:
    while state.ex1_rgba[1] > 0:
      state.ex1_rgba[1] -= 10
      yield
      time.sleep(0.1)
    state.ex1_rgba[1] = 0
    yield


def transform_fade_in_out(e: me.ClickEvent):
  """Update opacity"""
  state = me.state(State)
  if state.ex2_opacity == 0:
    while state.ex2_opacity < 1:
      state.ex2_opacity += 0.05
      yield
      time.sleep(0.1)
    state.ex2_opacity = 1.0
    yield
  else:
    while state.ex2_opacity > 0:
      state.ex2_opacity -= 0.05
      yield
      time.sleep(0.1)
    state.ex2_opacity = 0
    yield


def transform_width(e: me.ClickEvent):
  """Update the width by percentage."""
  state = me.state(State)
  if state.ex3_width == 0:
    while state.ex3_width < 100:
      state.ex3_width += 5
      yield
      time.sleep(0.1)
    state.ex3_width = 100
    yield
  else:
    while state.ex3_width > 0:
      state.ex3_width -= 5
      yield
      time.sleep(0.1)
    state.ex3_width = 0
    yield


def transform_margin(e: me.ClickEvent):
  """Update the position to create sense of movement."""
  state = me.state(State)
  if state.ex4_left == 0:
    while state.ex4_left < 200:
      state.ex4_left += 5
      yield
    state.ex4_left = 200
    yield
  else:
    while state.ex4_left > 0:
      state.ex4_left -= 5
      yield
    state.ex4_left = 0
    yield


def transform_rotate(e: me.ClickEvent):
  """Update the degrees to rotate."""
  state = me.state(State)
  if state.ex5_rotate_deg == 0:
    while state.ex5_rotate_deg < 365:
      state.ex5_rotate_deg += 5
      yield
    state.ex5_rotate_deg = 0
    yield


def transform_transform(e: me.ClickEvent):
  """Update the index to run different transform operations."""
  state = me.state(State)
  while state.ex6_transforms_index < len(TRANSFORM_OPERATIONS):
    yield
    time.sleep(0.2)
    state.ex6_transforms_index += 1
  state.ex6_transforms_index = 0
  yield
</page>

<page url=''>
import mesop as me

SAMPLE_MARKDOWN = """
# Sample Markdown Document

## Table of Contents
1. [Headers](#headers)
2. [Emphasis](#emphasis)
3. [Lists](#lists)
4. [Links](#links)
5. [Code](#code)
6. [Blockquotes](#blockquotes)
7. [Tables](#tables)
8. [Horizontal Rules](#horizontal-rules)

## Headers
# Header 1
## Header 2
### Header 3
#### Header 4
##### Header 5
###### Header 6

## Emphasis
*Italic text* or _Italic text_
**Bold text** or __Bold text__
***Bold and Italic*** or ___Bold and Italic___

## Lists

### Unordered List
- Item 1
- Item 2
    - Subitem 2.1
    - Subitem 2.2

### Ordered List
1. First item
2. Second item
    1. Subitem 2.1
    2. Subitem 2.2

## Links
[Google](https://www.google.com/)

## Code
Inline `code`

## Table

First Header  | Second Header
------------- | -------------
Content Cell { .foo }  | Content Cell { .foo }
Content Cell { .bar } | Content Cell { .bar }
"""


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/markdown_demo",
)
def app():
  me.markdown(SAMPLE_MARKDOWN)
</page>

<page url=''>
from dataclasses import fields

import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/headers",
)
def app():
  is_mobile = me.viewport_size().width < 640

  with me.box(style=me.Style(margin=me.Margin(bottom=15))):
    # Two section basic header with fluid width.
    # As an example, we don't use mobile view here since the header is short enough.
    with header(max_width=None):
      with header_section():
        me.text(
          "Mesop", type="headline-6", style=me.Style(margin=me.Margin(bottom=0))
        )

      with header_section():
        me.button("Home")
        me.button("About")
        me.button("FAQ")

  with me.box(style=me.Style(margin=me.Margin(bottom=15))):
    # Two section basic header.
    with header(is_mobile=is_mobile):
      with header_section():
        me.text(
          "Mesop", type="headline-6", style=me.Style(margin=me.Margin(bottom=0))
        )

      with header_section():
        me.button("Home")
        me.button("About")
        me.button("FAQ")

  with me.box(style=me.Style(margin=me.Margin(bottom=15))):
    # Three section basic header.
    with header(is_mobile=is_mobile):
      with header_section():
        me.text(
          "Mesop", type="headline-6", style=me.Style(margin=me.Margin(bottom=0))
        )

      with header_section():
        me.button("Home")
        me.button("About")
        me.button("FAQ")

      with header_section():
        me.button("Login", type="flat")

  with me.box(style=me.Style(margin=me.Margin(bottom=15))):
    # Centered header with overrides and icons
    with header(is_mobile=is_mobile, style=me.Style(justify_content="center")):
      with header_section():
        with me.content_button(
          style=me.Style(
            padding=me.Padding.symmetric(vertical=30, horizontal=25)
          )
        ):
          me.icon("home")
          me.text("Home")
        with me.content_button(
          style=me.Style(
            padding=me.Padding.symmetric(vertical=30, horizontal=25)
          )
        ):
          me.icon("info")
          me.text("About")
        with me.content_button(
          style=me.Style(
            padding=me.Padding.symmetric(vertical=30, horizontal=25)
          )
        ):
          me.icon("contact_support")
          me.text("FAQ")
        with me.content_button(
          style=me.Style(
            padding=me.Padding.symmetric(vertical=30, horizontal=25)
          )
        ):
          me.icon("login")
          me.text("Login")

  with me.box(style=me.Style(margin=me.Margin(bottom=15))):
    # Header with overridden background
    with header(
      is_mobile=is_mobile, style=me.Style(background="#0F0F11", color="#E3E3E3")
    ):
      with header_section():
        me.text(
          "Mesop", type="headline-6", style=me.Style(margin=me.Margin(bottom=0))
        )

      with header_section():
        me.button("Home", type="stroked", style=me.Style(color="#E3E3E3"))
        me.button("About", type="stroked", style=me.Style(color="#E3E3E3"))
        me.button("FAQ", type="stroked", style=me.Style(color="#E3E3E3"))

      with header_section():
        me.button("Login", type="flat")


@me.content_component
def header(
  *,
  style: me.Style | None = None,
  is_mobile: bool = False,
  max_width: int | None = 1000,
):
  """Creates a simple header component.

  Args:
    style: Override the default styles, such as background color, etc.
    is_mobile: Use mobile layout. Arranges each section vertically.
    max_width: Sets the maximum width of the header. Use None for fluid header.
  """
  default_flex_style = (
    _DEFAULT_MOBILE_FLEX_STYLE if is_mobile else _DEFAULT_FLEX_STYLE
  )
  if max_width and me.viewport_size().width >= max_width:
    default_flex_style = merge_styles(
      default_flex_style,
      me.Style(width=max_width, margin=me.Margin.symmetric(horizontal="auto")),
    )

  # The style override is a bit hacky here since we apply the override styles to both
  # boxes here which could cause problems depending on what styles are added.
  with me.box(style=merge_styles(_DEFAULT_STYLE, style)):
    with me.box(style=merge_styles(default_flex_style, style)):
      me.slot()


@me.content_component
def header_section():
  """Adds a section to the header."""
  with me.box(style=me.Style(display="flex", gap=5)):
    me.slot()


def merge_styles(
  default: me.Style, overrides: me.Style | None = None
) -> me.Style:
  """Merges two styles together.

  Args:
    default: The starting style
    overrides: Any set styles will override styles in default
  """
  if not overrides:
    overrides = me.Style()

  default_fields = {
    field.name: getattr(default, field.name) for field in fields(me.Style)
  }
  override_fields = {
    field.name: getattr(overrides, field.name)
    for field in fields(me.Style)
    if getattr(overrides, field.name) is not None
  }

  return me.Style(**default_fields | override_fields)


_DEFAULT_STYLE = me.Style(
  background=me.theme_var("surface-container"),
  border=me.Border.symmetric(
    vertical=me.BorderSide(
      width=1,
      style="solid",
      color=me.theme_var("outline-variant"),
    )
  ),
  padding=me.Padding.all(10),
)

_DEFAULT_FLEX_STYLE = me.Style(
  align_items="center",
  display="flex",
  gap=5,
  justify_content="space-between",
)

_DEFAULT_MOBILE_FLEX_STYLE = me.Style(
  align_items="center",
  display="flex",
  flex_direction="column",
  gap=12,
  justify_content="center",
)
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  raw_value: str
  selected_value: str


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/autocomplete",
)
def app():
  state = me.state(State)

  with me.box(style=me.Style(margin=me.Margin.all(15))):
    me.autocomplete(
      label="Select state",
      options=_make_autocomplete_options(),
      on_selection_change=on_value_change,
      on_enter=on_value_change,
      on_input=on_input,
    )

    if state.selected_value:
      me.text("Selected: " + state.selected_value)


def on_value_change(
  e: me.AutocompleteEnterEvent | me.AutocompleteSelectionChangeEvent,
):
  state = me.state(State)
  state.selected_value = e.value


def on_input(e: me.InputEvent):
  state = me.state(State)
  state.raw_value = e.value


def _make_autocomplete_options() -> list[me.AutocompleteOptionGroup]:
  """Creates and filter autocomplete options.

  The states list assumed to be alphabetized and we group by the first letter of the
  state's name.
  """
  states_options_list = []
  sub_group = None
  for state in _STATES:
    if not sub_group or sub_group.label != state[0]:
      if sub_group:
        states_options_list.append(sub_group)
      sub_group = me.AutocompleteOptionGroup(label=state[0], options=[])
    sub_group.options.append(me.AutocompleteOption(label=state, value=state))
  if sub_group:
    states_options_list.append(sub_group)
  return states_options_list


_STATES = [
  "Alabama",
  "Alaska",
  "Arizona",
  "Arkansas",
  "California",
  "Colorado",
  "Connecticut",
  "Delaware",
  "Florida",
  "Georgia",
  "Hawaii",
  "Idaho",
  "Illinois",
  "Indiana",
  "Iowa",
  "Kansas",
  "Kentucky",
  "Louisiana",
  "Maine",
  "Maryland",
  "Massachusetts",
  "Michigan",
  "Minnesota",
  "Mississippi",
  "Missouri",
  "Montana",
  "Nebraska",
  "Nevada",
  "New Hampshire",
  "New Jersey",
  "New Mexico",
  "New York",
  "North Carolina",
  "North Dakota",
  "Ohio",
  "Oklahoma",
  "Oregon",
  "Pennsylvania",
  "Rhode Island",
  "South Carolina",
  "South Dakota",
  "Tennessee",
  "Texas",
  "Utah",
  "Vermont",
  "Virginia",
  "Washington",
  "West Virginia",
  "Wisconsin",
  "Wyoming",
]
</page>

<page url=''>
# Disable import sort ordering due to the hack needed
# to ensure local imports.
# ruff: noqa: E402

import base64
import inspect
import os
import sys
from dataclasses import dataclass
from typing import Literal

import mesop as me

# Append the current directory to sys.path to ensure local imports work
# This is required so mesop/examples/__init__.py can import the modules
# imported below.
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
  sys.path.append(current_dir)

import glob

import audio as audio
import autocomplete as autocomplete
import badge as badge
import basic_animation as basic_animation
import box as box
import button as button
import chat as chat
import chat_inputs as chat_inputs
import checkbox as checkbox
import code_demo as code_demo  # cannot call it code due to python library naming conflict
import dialog as dialog
import divider as divider
import embed as embed
import feedback as feedback
import grid_table as grid_table
import headers as headers
import html_demo as html_demo
import icon as icon
import image as image
import input as input
import link as link
import llm_playground as llm_playground
import llm_rewriter as llm_rewriter
import markdown_demo as markdown_demo  # cannot call it markdown due to python library naming conflict
import markdown_editor as markdown_editor
import plot as plot
import progress_bar as progress_bar
import progress_spinner as progress_spinner
import radio as radio
import select_demo as select_demo  # cannot call it select due to python library naming conflict
import sidenav as sidenav
import slide_toggle as slide_toggle
import slider as slider
import snackbar as snackbar
import table as table
import text as text
import text_to_image as text_to_image
import text_to_text as text_to_text
import textarea as textarea
import tooltip as tooltip
import uploader as uploader
import video as video


@dataclass
class Example:
  # module_name (should also be the path name)
  name: str


@dataclass
class Section:
  name: str
  examples: list[Example]


FIRST_SECTIONS = [
  Section(
    name="Quick start",
    examples=[
      Example(name="chat"),
      Example(name="text_to_image"),
      Example(name="text_to_text"),
    ],
  ),
  Section(
    name="Use cases",
    examples=[
      Example(name="llm_rewriter"),
      Example(name="llm_playground"),
      Example(name="markdown_editor"),
    ],
  ),
  Section(
    name="Patterns",
    examples=[
      Example(name="dialog"),
      Example(name="grid_table"),
      Example(name="headers"),
      Example(name="snackbar"),
      Example(name="chat_inputs"),
    ],
  ),
  Section(
    name="Misc",
    examples=[
      Example(name="basic_animation"),
      Example(name="feedback"),
    ],
  ),
]

COMPONENTS_SECTIONS = [
  Section(
    name="Layout",
    examples=[
      Example(name="box"),
      Example(name="sidenav"),
    ],
  ),
  Section(
    name="Text",
    examples=[
      Example(name="text"),
      Example(name="markdown_demo"),
      Example(name="code_demo"),
    ],
  ),
  Section(
    name="Media",
    examples=[
      Example(name="image"),
      Example(name="audio"),
      Example(name="video"),
    ],
  ),
  Section(
    name="Form",
    examples=[
      Example(name="autocomplete"),
      Example(name="button"),
      Example(name="checkbox"),
      Example(name="input"),
      Example(name="textarea"),
      Example(name="radio"),
      Example(name="select_demo"),
      Example(name="slide_toggle"),
      Example(name="slider"),
      Example(name="uploader"),
    ],
  ),
  Section(
    name="Visual",
    examples=[
      Example(name="badge"),
      Example(name="divider"),
      Example(name="icon"),
      Example(name="progress_bar"),
      Example(name="progress_spinner"),
      Example(name="table"),
      Example(name="tooltip"),
    ],
  ),
  Section(
    name="Web",
    examples=[
      Example(name="embed"),
      Example(name="html_demo"),
      Example(name="link"),
    ],
  ),
  Section(
    name="Others",
    examples=[
      Example(name="plot"),
    ],
  ),
]

ALL_SECTIONS = FIRST_SECTIONS + COMPONENTS_SECTIONS

BORDER_SIDE = me.BorderSide(
  style="solid",
  width=1,
  color="#dcdcdc",
)


@me.stateclass
class State:
  current_demo: str
  panel_fullscreen: Literal["preview", "editor", None] = None


screenshots: dict[str, str] = {}


def load_home_page(e: me.LoadEvent):
  yield
  screenshot_dir = os.path.join(current_dir, "screenshots")
  screenshot_files = glob.glob(os.path.join(screenshot_dir, "*.webp"))

  for screenshot_file in screenshot_files:
    image_name = os.path.basename(screenshot_file).split(".")[0]
    with open(screenshot_file, "rb") as image_file:
      encoded_string = base64.b64encode(image_file.read()).decode()
      screenshots[image_name] = "data:image/webp;base64," + encoded_string

  yield


@me.page(
  title="Mesop Demos",
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  on_load=load_home_page,
)
def main_page():
  header()
  with me.box(
    style=me.Style(
      flex_grow=1,
      display="flex",
    )
  ):
    if is_desktop():
      side_menu()
    with me.box(
      style=me.Style(
        width="calc(100% - 150px)" if is_desktop() else "100%",
        display="flex",
        gap=24,
        flex_direction="column",
        padding=me.Padding.all(24),
        overflow_y="auto",
      )
    ):
      with me.box(
        style=me.Style(
          height="calc(100vh - 120px)",
        )
      ):
        for section in ALL_SECTIONS:
          with me.box(style=me.Style(margin=me.Margin(bottom=28))):
            me.text(
              section.name,
              style=me.Style(
                font_weight=500,
                font_size=20,
                margin=me.Margin(
                  bottom=16,
                ),
              ),
            )
            with me.box(
              style=me.Style(
                display="flex",
                flex_direction="row",
                flex_wrap="wrap",
                gap=28,
              )
            ):
              for example in section.examples:
                example_card(example.name)


def navigate_example_card(e: me.ClickEvent):
  me.navigate("/embed/" + e.key)


def example_card(name: str):
  with me.box(
    key=name,
    on_click=navigate_example_card,
    style=me.Style(
      border=me.Border.all(
        me.BorderSide(
          width=1,
          color="rgb(220, 220, 220)",
          style="solid",
        )
      ),
      box_shadow="rgba(0, 0, 0, 0.2) 0px 3px 1px -2px, rgba(0, 0, 0, 0.14) 0px 2px 2px, rgba(0, 0, 0, 0.12) 0px 1px 5px",
      cursor="pointer",
      width="min(100%, 150px)",
      border_radius=12,
      background="#fff",
    ),
  ):
    image_url = screenshots.get(name, "")
    me.box(
      style=me.Style(
        background=f'url("{image_url}") center / cover',
        height=112,
        width=150,
      )
    )
    me.text(
      format_example_name(name),
      style=me.Style(
        font_weight=500,
        font_size=18,
        padding=me.Padding.all(12),
        border=me.Border(
          top=me.BorderSide(
            width=1,
            style="solid",
            color="rgb(220, 220, 220)",
          )
        ),
      ),
    )


def on_load_embed(e: me.LoadEvent):
  if not is_desktop():
    me.state(State).panel_fullscreen = "preview"


def create_main_fn(example: Example):
  @me.page(
    on_load=on_load_embed,
    title="Mesop Demos",
    path="/embed/" + example.name,
    security_policy=me.SecurityPolicy(
      allowed_iframe_parents=["https://google.github.io"]
    ),
  )
  def main():
    with me.box(
      style=me.Style(
        height="100%",
        display="flex",
        flex_direction="column",
        background="#fff",
      )
    ):
      header(demo_name=example.name)
      body(example.name)

  return main


for section in FIRST_SECTIONS + COMPONENTS_SECTIONS:
  for example in section.examples:
    create_main_fn(example)


def body(current_demo: str):
  state = me.state(State)
  with me.box(
    style=me.Style(
      flex_grow=1,
      display="flex",
    )
  ):
    if is_desktop():
      side_menu()
    src = "/" + current_demo
    with me.box(
      style=me.Style(
        width="calc(100% - 150px)" if is_desktop() else "100%",
        display="grid",
        grid_template_columns="1fr 1fr"
        if state.panel_fullscreen is None
        else "1fr",
      )
    ):
      if state.panel_fullscreen != "editor":
        demo_ui(src)
      if state.panel_fullscreen != "preview":
        demo_code(inspect.getsource(get_module(current_demo)))


def demo_ui(src: str):
  state = me.state(State)
  with me.box(
    style=me.Style(flex_grow=1),
  ):
    with me.box(
      style=me.Style(
        display="flex",
        justify_content="space-between",
        align_items="center",
        border=me.Border(bottom=BORDER_SIDE),
      )
    ):
      me.text(
        "Preview",
        style=me.Style(
          font_weight=500,
          padding=me.Padding.all(14),
        ),
      )
      if is_desktop():
        with me.tooltip(
          position="above",
          message="Minimize"
          if state.panel_fullscreen == "preview"
          else "Maximize",
        ):
          with me.content_button(type="icon", on_click=toggle_fullscreen):
            me.icon(
              "close_fullscreen"
              if state.panel_fullscreen == "preview"
              else "fullscreen"
            )
      else:
        swap_button()
    me.embed(
      src=src,
      style=me.Style(
        border=me.Border.all(me.BorderSide(width=0)),
        border_radius=2,
        height="calc(100vh - 106px)",
        width="100%",
      ),
    )


def swap_button():
  state = me.state(State)
  with me.tooltip(
    position="above",
    message="Swap for code"
    if state.panel_fullscreen == "preview"
    else "Swap for preview",
  ):
    with me.content_button(type="icon", on_click=swap_fullscreen):
      me.icon("swap_horiz")


def swap_fullscreen(e: me.ClickEvent):
  state = me.state(State)
  if state.panel_fullscreen == "preview":
    state.panel_fullscreen = "editor"
  else:
    state.panel_fullscreen = "preview"


def toggle_fullscreen(e: me.ClickEvent):
  state = me.state(State)
  if state.panel_fullscreen == "preview":
    state.panel_fullscreen = None
  else:
    state.panel_fullscreen = "preview"


def demo_code(code_arg: str):
  with me.box(
    style=me.Style(
      flex_grow=1,
      overflow_x="hidden",
      overflow_y="hidden",
      border=me.Border(
        left=BORDER_SIDE,
      ),
    )
  ):
    with me.box(
      style=me.Style(
        display="flex",
        justify_content="space-between",
        align_items="center",
        border=me.Border(bottom=BORDER_SIDE),
      )
    ):
      me.text(
        "Code",
        style=me.Style(
          font_weight=500,
          padding=me.Padding.all(14),
        ),
      )
      if not is_desktop():
        swap_button()
    # Use four backticks for code fence to avoid conflicts with backticks being used
    # within the displayed code.
    me.markdown(
      f"""````
{code_arg}
````
              """,
      style=me.Style(
        border=me.Border(
          right=BORDER_SIDE,
        ),
        font_size=13,
        padding=me.Padding.all(12),
        height="calc(100vh - 106px)",
        overflow_y="auto",
        width="100%",
      ),
    )


def header(demo_name: str | None = None):
  with me.box(
    style=me.Style(
      border=me.Border(
        bottom=me.BorderSide(
          style="solid",
          width=1,
          color="#dcdcdc",
        )
      ),
      overflow_x="clip",
    )
  ):
    with me.box(
      style=me.Style(
        display="flex",
        align_items="end",
        justify_content="space-between",
        margin=me.Margin(left=12, right=12, bottom=12),
        font_size=24,
      )
    ):
      with me.box(style=me.Style(display="flex")):
        with me.box(
          style=me.Style(display="flex", cursor="pointer"),
          on_click=navigate_home,
        ):
          me.text(
            "Mesop", style=me.Style(font_weight=700, margin=me.Margin(right=8))
          )
          me.text("Demos ")
        if demo_name:
          me.text(
            "— " + format_example_name(demo_name),
            style=me.Style(white_space="nowrap", text_overflow="ellipsis"),
          )
      with me.box(style=me.Style(display="flex", align_items="baseline")):
        with me.box(
          style=me.Style(
            display="flex",
            align_items="baseline",
          ),
        ):
          me.markdown(
            "<a href='https://github.com/google/mesop/' target='_blank'>google/mesop</a>",
            style=me.Style(
              font_size=18,
              margin=me.Margin(left=8, right=4, bottom=-16, top=-16),
            ),
          )
          me.image(
            src="https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png",
            style=me.Style(
              height=36,
              position="relative",
              top=8,
            ),
          )
        me.text(
          "v" + me.__version__,
          style=me.Style(font_size=18, margin=me.Margin(left=16)),
        )


def navigate_home(e: me.ClickEvent):
  me.navigate("/")


def side_menu():
  with me.box(
    style=me.Style(
      padding=me.Padding.all(12),
      width=150,
      flex_grow=0,
      line_height="1.5",
      border=me.Border(right=BORDER_SIDE),
      overflow_x="hidden",
      height="calc(100vh - 60px)",
      overflow_y="auto",
    )
  ):
    for section in FIRST_SECTIONS:
      nav_section(section)
    with me.box(
      style=me.Style(
        margin=me.Margin.symmetric(
          horizontal=-16,
          vertical=16,
        ),
      )
    ):
      me.divider()
    me.text(
      "Components",
      style=me.Style(
        letter_spacing="0.5px",
        margin=me.Margin(bottom=6),
      ),
    )
    for section in COMPONENTS_SECTIONS:
      nav_section(section)


def nav_section(section: Section):
  with me.box(style=me.Style(margin=me.Margin(bottom=12))):
    me.text(section.name, style=me.Style(font_weight=700))
    for example in section.examples:
      example_name = format_example_name(example.name)
      path = f"/embed/{example.name}"
      with me.box(
        style=me.Style(color="#0B57D0", cursor="pointer"),
        on_click=set_demo,
        key=path,
      ):
        me.text(example_name)


def set_demo(e: me.ClickEvent):
  me.navigate(e.key)


def format_example_name(name: str):
  return (
    (" ".join(name.split("_")))
    .capitalize()
    .replace("Llm", "LLM")
    .replace(" demo", "")
  )


def get_module(module_name: str):
  if module_name in globals():
    return globals()[module_name]
  raise me.MesopDeveloperException(f"Module {module_name} not supported")


def is_desktop():
  return me.viewport_size().width > 760
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  toggled: bool = False


def on_change(event: me.SlideToggleChangeEvent):
  s = me.state(State)
  s.toggled = not s.toggled


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/slide_toggle",
)
def app():
  me.slide_toggle(label="Slide toggle", on_change=on_change)
  s = me.state(State)
  me.text(text=f"Toggled: {s.toggled}")
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/video",
)
def app():
  me.video(
    src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm",
    style=me.Style(height=300, width=300),
  )
</page>

<page url=''>
import mesop as me


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/image",
)
def app():
  me.image(
    src="https://interactive-examples.mdn.mozilla.net/media/cc0-images/grapefruit-slice-332-332.jpg",
    alt="Grapefruit",
    style=me.Style(width="100%"),
  )
</page>

<page url=''>
import mesop as me


@me.page(path="/html_demo")
def app():
  me.text("Sanitized HTML")
  me.html(
    """
Custom HTML
<a href="https://google.github.io/mesop/" target="_blank">mesop</a>
""",
    mode="sanitized",
  )
  with me.box(style=me.Style(margin=me.Margin.symmetric(vertical=24))):
    me.divider()
  me.text("Sandboxed HTML")
  me.html(
    "hi<script>document.body.innerHTML = 'iamsandboxed'; </script>",
    mode="sandboxed",
  )
</page>

<page url=''>
import mesop as me


@me.stateclass
class State:
  checked: bool


def on_update(event: me.CheckboxChangeEvent):
  state = me.state(State)
  state.checked = event.checked


@me.page(
  security_policy=me.SecurityPolicy(
    allowed_iframe_parents=["https://google.github.io"]
  ),
  path="/checkbox",
)
def app():
  state = me.state(State)
  me.checkbox(
    "Simple checkbox",
    on_change=on_update,
  )

  if state.checked:
    me.text(text="is checked")
  else:
    me.text(text="is not checked")
</page>
